<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Othello Twist - ‡πÄ‡∏Å‡∏°‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÉ‡∏Ñ‡∏£</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Kanit:wght@300;400;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        :root {
            --neon-cyan: #00f5ff;
            --neon-magenta: #ff00ff;
            --neon-yellow: #ffff00;
            --dark-bg: #0a0a1a;
            --darker-bg: #050510;
        }

        html, body {
            font-family: 'Kanit', sans-serif;
            background: var(--dark-bg);
            min-height: 100vh;
            min-height: 100dvh;
            overflow-x: hidden;
            touch-action: manipulation;
        }

        .font-orbitron {
            font-family: 'Orbitron', monospace;
        }

        .animated-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background: 
                radial-gradient(ellipse at 20% 80%, rgba(0, 245, 255, 0.1) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 20%, rgba(255, 0, 255, 0.1) 0%, transparent 50%),
                var(--darker-bg);
        }

        .grid-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background-image: 
                linear-gradient(rgba(0, 245, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 245, 255, 0.03) 1px, transparent 1px);
            background-size: 50px 50px;
        }

        .neon-text {
            text-shadow: 0 0 5px var(--neon-cyan), 0 0 10px var(--neon-cyan), 0 0 20px var(--neon-cyan);
        }

        .neon-text-magenta {
            text-shadow: 0 0 5px var(--neon-magenta), 0 0 10px var(--neon-magenta);
        }

        .game-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 2px;
            padding: 6px;
            background: linear-gradient(135deg, #0d3320 0%, #1a472a 50%, #0d3320 100%);
            border-radius: 12px;
            box-shadow: 0 0 30px rgba(0, 245, 255, 0.3), inset 0 0 60px rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(0, 245, 255, 0.3);
            aspect-ratio: 1;
        }

        .cell {
            aspect-ratio: 1;
            background: linear-gradient(135deg, #2d5a3d 0%, #1a472a 100%);
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        .cell:active:not(.has-disc) {
            background: linear-gradient(135deg, #3d7a5d 0%, #2a5a3a 100%);
        }

        .cell.valid-move::after {
            content: '';
            position: absolute;
            width: 30%;
            height: 30%;
            background: rgba(0, 245, 255, 0.6);
            border-radius: 50%;
            animation: pulse 1.5s ease-in-out infinite;
        }

        .cell.black-hole {
            background: radial-gradient(circle, #000 0%, #1a0a2e 50%, #000 100%);
            animation: blackHolePulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.3); opacity: 0.9; }
        }

        @keyframes blackHolePulse {
            0%, 100% { box-shadow: inset 0 0 20px #ff00ff; }
            50% { box-shadow: inset 0 0 40px #ff00ff; }
        }

        .disc {
            width: 80%;
            height: 80%;
            border-radius: 50%;
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            position: relative;
        }

        .disc-black {
            background: linear-gradient(145deg, #2a2a2a 0%, #0a0a0a 100%);
            box-shadow: inset 3px 3px 6px rgba(255, 255, 255, 0.1), inset -3px -3px 6px rgba(0, 0, 0, 0.8), 0 4px 8px rgba(0, 0, 0, 0.5);
        }

        .disc-white {
            background: linear-gradient(145deg, #ffffff 0%, #d0d0d0 100%);
            box-shadow: inset 3px 3px 6px rgba(255, 255, 255, 0.8), inset -3px -3px 6px rgba(0, 0, 0, 0.2), 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .disc-gold {
            background: linear-gradient(145deg, #ffd700 0%, #b8860b 100%) !important;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.6), inset 2px 2px 4px rgba(255, 255, 255, 0.5) !important;
            animation: goldGlow 2s ease-in-out infinite;
        }

        .disc-shielded::after {
            content: 'üõ°Ô∏è';
            position: absolute;
            font-size: 0.5em;
            top: -2px;
            right: -2px;
        }

        @keyframes goldGlow {
            0%, 100% { box-shadow: 0 0 15px rgba(255, 215, 0, 0.6); }
            50% { box-shadow: 0 0 25px rgba(255, 215, 0, 0.9); }
        }

        .power-up-cell {
            position: absolute;
            font-size: 1.2em;
            animation: powerUpFloat 2s ease-in-out infinite;
            filter: drop-shadow(0 0 8px rgba(255, 255, 0, 0.8));
        }

        @keyframes powerUpFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-3px); }
        }

        .power-up-slot {
            width: 44px;
            height: 44px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(0, 245, 255, 0.3);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.3em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .power-up-slot:active, .power-up-slot.selected {
            border-color: var(--neon-magenta);
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.7);
            transform: scale(1.05);
        }

        .btn-neon {
            padding: 10px 20px;
            background: transparent;
            border: 2px solid var(--neon-cyan);
            color: var(--neon-cyan);
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            font-size: 0.75rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-neon:active {
            background: var(--neon-cyan);
            color: var(--dark-bg);
        }

        .btn-mode {
            padding: 8px 14px;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: rgba(255, 255, 255, 0.7);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.8rem;
        }

        .btn-mode.active {
            background: rgba(0, 245, 255, 0.2);
            border-color: var(--neon-cyan);
            color: var(--neon-cyan);
        }

        .popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 999;
            backdrop-filter: blur(5px);
        }

        .event-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: radial-gradient(ellipse at center, rgba(20, 0, 40, 0.98) 0%, rgba(10, 0, 20, 0.98) 100%);
            border: 3px solid var(--neon-magenta);
            border-radius: 20px;
            padding: 25px 35px;
            text-align: center;
            z-index: 1000;
            animation: popupAppear 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            box-shadow: 0 0 60px rgba(255, 0, 255, 0.5);
            max-width: 85vw;
        }

        .pass-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid var(--neon-yellow);
            border-radius: 15px;
            padding: 20px 35px;
            text-align: center;
            z-index: 1000;
            animation: popupAppear 0.3s ease-out;
            box-shadow: 0 0 40px rgba(255, 255, 0, 0.3);
        }

        .info-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid var(--neon-cyan);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            z-index: 1000;
            animation: popupAppear 0.3s ease-out;
            box-shadow: 0 0 40px rgba(0, 245, 255, 0.3);
            max-width: 90vw;
            max-height: 80vh;
            overflow-y: auto;
        }

        @keyframes popupAppear {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        .event-icon {
            font-size: 3.5em;
            margin-bottom: 10px;
            animation: eventIconBounce 0.5s ease-in-out infinite alternate;
        }

        @keyframes eventIconBounce {
            0% { transform: scale(1); }
            100% { transform: scale(1.1); }
        }

        .toast {
            position: fixed;
            top: 12%;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.95) 0%, rgba(255, 165, 0, 0.95) 100%);
            color: #000;
            padding: 10px 25px;
            border-radius: 25px;
            font-family: 'Orbitron', monospace;
            font-weight: 900;
            font-size: 0.9em;
            z-index: 1000;
            animation: toastSlide 2.5s ease-out forwards;
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.8);
            white-space: nowrap;
            max-width: 90vw;
            text-align: center;
        }

        .toast.info {
            background: linear-gradient(135deg, rgba(0, 245, 255, 0.95) 0%, rgba(0, 150, 200, 0.95) 100%);
        }

        .toast.power {
            background: linear-gradient(135deg, rgba(255, 0, 255, 0.95) 0%, rgba(150, 0, 200, 0.95) 100%);
            color: #fff;
        }

        @keyframes toastSlide {
            0% { transform: translateX(-50%) translateY(-30px); opacity: 0; }
            15% { transform: translateX(-50%) translateY(0); opacity: 1; }
            85% { transform: translateX(-50%) translateY(0); opacity: 1; }
            100% { transform: translateX(-50%) translateY(-30px); opacity: 0; }
        }

        .score-card {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 6px 12px;
            backdrop-filter: blur(10px);
        }

        .score-value {
            font-family: 'Orbitron', monospace;
            font-size: 1.6em;
            font-weight: 900;
        }

        .turn-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 14px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 20px;
            border: 2px solid;
            font-size: 0.8rem;
        }

        .turn-indicator.player-turn {
            border-color: var(--neon-cyan);
            box-shadow: 0 0 15px rgba(0, 245, 255, 0.3);
        }

        .turn-indicator.ai-turn {
            border-color: var(--neon-magenta);
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.3);
        }

        .ai-thinking {
            display: flex;
            gap: 4px;
        }

        .ai-thinking span {
            width: 6px;
            height: 6px;
            background: var(--neon-magenta);
            border-radius: 50%;
            animation: thinking 1.4s ease-in-out infinite;
        }

        .ai-thinking span:nth-child(2) { animation-delay: 0.2s; }
        .ai-thinking span:nth-child(3) { animation-delay: 0.4s; }

        @keyframes thinking {
            0%, 100% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.5); opacity: 1; }
        }

        .screen-shake {
            animation: shake 0.5s ease-in-out;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20%, 60% { transform: translateX(-5px); }
            40%, 80% { transform: translateX(5px); }
        }

        .result-screen {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(10, 10, 30, 0.98) 0%, rgba(5, 5, 15, 0.98) 100%);
            border-radius: 20px;
            padding: 25px;
            text-align: center;
            z-index: 1001;
            width: 88%;
            max-width: 360px;
            animation: resultAppear 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        .result-screen.victory {
            border: 3px solid var(--neon-cyan);
            box-shadow: 0 0 60px rgba(0, 245, 255, 0.5);
        }

        .result-screen.defeat {
            border: 3px solid var(--neon-magenta);
            box-shadow: 0 0 60px rgba(255, 0, 255, 0.5);
        }

        @keyframes resultAppear {
            0% { transform: translate(-50%, -50%) scale(0) rotate(-10deg); opacity: 0; }
            100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); opacity: 1; }
        }

        .help-btn {
            position: fixed;
            bottom: 15px;
            right: 15px;
            width: 45px;
            height: 45px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--neon-cyan);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.3em;
            cursor: pointer;
            z-index: 100;
        }

        @media (max-width: 400px) {
            .game-board { gap: 1px; padding: 4px; }
            .score-value { font-size: 1.4em; }
            .power-up-slot { width: 38px; height: 38px; font-size: 1.1em; }
            .btn-neon { padding: 8px 14px; font-size: 0.65rem; }
            .power-up-cell { font-size: 1em; }
        }

        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: rgba(0, 0, 0, 0.3); }
        ::-webkit-scrollbar-thumb { background: var(--neon-cyan); border-radius: 3px; }
    </style>
</head>
<body>
    <div class="animated-bg"></div>
    <div class="grid-overlay"></div>
    <div id="app"></div>

    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useRef } = React;

        const BOARD_SIZE = 8;
        const DIRECTIONS = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];

        const POWER_UPS = {
            BOMB: { icon: 'üí£', name: 'Bomb', desc: '‡∏£‡∏∞‡πÄ‡∏ö‡∏¥‡∏î‡∏´‡∏°‡∏≤‡∏Å 3√ó3 ‡∏£‡∏≠‡∏ö‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å' },
            SWAP: { icon: 'üîÑ', name: 'Swap', desc: '‡∏™‡∏•‡∏±‡∏ö‡∏™‡∏µ‡∏´‡∏°‡∏≤‡∏Å‡∏ó‡∏±‡πâ‡∏á‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô ‡∏î‡∏≥‚Üî‡∏Ç‡∏≤‡∏ß' },
            SHIELD: { icon: 'üõ°Ô∏è', name: 'Shield', desc: '‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏´‡∏°‡∏≤‡∏Å‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì 1 ‡∏ï‡∏±‡∏ß ‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡∏ñ‡∏π‡∏Å‡∏û‡∏•‡∏¥‡∏Å 3 ‡∏ï‡∏≤' },
            DOUBLE: { icon: '‚ö°', name: 'Double', desc: '‡πÄ‡∏î‡∏¥‡∏ô‡πÑ‡∏î‡πâ 2 ‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ï‡∏¥‡∏î‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ô' },
            GHOST: { icon: 'üëª', name: 'Ghost', desc: '‡∏ß‡∏≤‡∏á‡∏´‡∏°‡∏≤‡∏Å‡∏ó‡∏µ‡πà‡πÑ‡∏´‡∏ô‡∏Å‡πá‡πÑ‡∏î‡πâ 1 ‡∏Ñ‡∏£‡∏±‡πâ‡∏á ‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Ç‡∏ô‡∏≤‡∏ö' },
            SNIPER: { icon: 'üéØ', name: 'Sniper', desc: '‡∏û‡∏•‡∏¥‡∏Å‡∏´‡∏°‡∏≤‡∏Å‡∏®‡∏±‡∏ï‡∏£‡∏π‡∏ï‡∏±‡∏ß‡πÑ‡∏´‡∏ô‡∏Å‡πá‡πÑ‡∏î‡πâ 1 ‡∏ï‡∏±‡∏ß' }
        };

        const EVENTS = {
            EARTHQUAKE: { icon: 'üåä', name: 'Earthquake', desc: '‡∏´‡∏°‡∏≤‡∏Å‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÄ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏õ‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏™‡∏∏‡πà‡∏°!' },
            BLACKHOLE: { icon: 'üï≥Ô∏è', name: 'Black Hole', desc: '‡πÄ‡∏Å‡∏¥‡∏î‡∏´‡∏•‡∏∏‡∏°‡∏î‡∏≥ 4 ‡∏ä‡πà‡∏≠‡∏á ‡∏ß‡∏≤‡∏á‡∏´‡∏°‡∏≤‡∏Å‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ!' },
            RAINBOW: { icon: 'üåà', name: 'Rainbow', desc: '‡∏´‡∏°‡∏≤‡∏Å‡∏™‡∏∏‡πà‡∏° 5 ‡∏ï‡∏±‡∏ß‡∏Å‡∏•‡∏≤‡∏¢‡πÄ‡∏õ‡πá‡∏ô‡∏´‡∏°‡∏≤‡∏Å‡∏ó‡∏≠‡∏á (2 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô)!' },
            TIMEWARP: { icon: '‚è∞', name: 'Time Warp', desc: '‡∏¢‡πâ‡∏≠‡∏ô‡πÄ‡∏ß‡∏•‡∏≤‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ 3 ‡∏ï‡∏≤!' },
            MIRROR: { icon: 'üé≠', name: 'Mirror', desc: '‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô‡∏™‡∏∞‡∏ó‡πâ‡∏≠‡∏ô‡πÅ‡∏ô‡∏ß‡∏ô‡∏≠‡∏ô!' },
            CHAOS: { icon: 'üå™Ô∏è', name: 'Chaos', desc: '‡∏´‡∏°‡∏≤‡∏Å‡∏™‡∏∏‡πà‡∏° 6 ‡∏ï‡∏±‡∏ß‡∏™‡∏•‡∏±‡∏ö‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏Å‡∏±‡∏ô!' }
        };

        const DISC_INFO = {
            gold: { icon: 'ü•á', name: '‡∏´‡∏°‡∏≤‡∏Å‡∏ó‡∏≠‡∏á', desc: '‡∏ô‡∏±‡∏ö 2 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡πÅ‡∏ó‡∏ô 1' }
        };

        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx = null;

        const playSound = (type) => {
            try {
                if (!audioCtx) audioCtx = new AudioContext();
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                const sounds = {
                    place: { freq: 440, dur: 0.1, type: 'sine' },
                    flip: { freq: 660, dur: 0.15, type: 'sine' },
                    powerup: { freq: 880, dur: 0.3, type: 'square' },
                    combo: { freq: 1000, dur: 0.4, type: 'sawtooth' },
                    event: { freq: 220, dur: 0.6, type: 'triangle' },
                    victory: { freq: 523, dur: 0.8, type: 'sine' },
                    defeat: { freq: 196, dur: 0.8, type: 'sine' },
                    pass: { freq: 300, dur: 0.3, type: 'triangle' }
                };
                const s = sounds[type] || sounds.place;
                osc.type = s.type;
                osc.frequency.setValueAtTime(s.freq, audioCtx.currentTime);
                gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + s.dur);
                osc.start(audioCtx.currentTime);
                osc.stop(audioCtx.currentTime + s.dur);
            } catch (e) {}
        };

        function OthelloTwist() {
            const [board, setBoard] = useState(() => initBoard());
            const [currentPlayer, setCurrentPlayer] = useState('black');
            const [gameMode, setGameMode] = useState('chaos');
            const [difficulty, setDifficulty] = useState('medium');
            const [gameState, setGameState] = useState('menu');
            const [scores, setScores] = useState({ black: 2, white: 2 });
            const [powerUps, setPowerUps] = useState([]);
            const [selectedPowerUp, setSelectedPowerUp] = useState(null);
            const [boardPowerUps, setBoardPowerUps] = useState({});
            const [blackHoles, setBlackHoles] = useState([]);
            const [shieldedDiscs, setShieldedDiscs] = useState([]);
            const [turnCount, setTurnCount] = useState(0);
            const [nextEventIn, setNextEventIn] = useState(5);
            const [currentEvent, setCurrentEvent] = useState(null);
            const [toast, setToast] = useState(null);
            const [isAIThinking, setIsAIThinking] = useState(false);
            const [doubleTurnActive, setDoubleTurnActive] = useState(false);
            const [ghostModeActive, setGhostModeActive] = useState(false);
            const [sniperModeActive, setSniperModeActive] = useState(false);
            const [gameHistory, setGameHistory] = useState([]);
            const [screenShake, setScreenShake] = useState(false);
            const [result, setResult] = useState(null);
            const [stats, setStats] = useState({ combos: 0, powerUpsUsed: 0, eventsLived: 0 });
            const [passNotification, setPassNotification] = useState(null);
            const [showHelp, setShowHelp] = useState(false);
            const [seenItems, setSeenItems] = useState(new Set());

            function initBoard() {
                const b = Array(8).fill(null).map(() => Array(8).fill(null).map(() => ({ player: null, type: 'normal' })));
                b[3][3] = { player: 'white', type: 'normal' };
                b[3][4] = { player: 'black', type: 'normal' };
                b[4][3] = { player: 'black', type: 'normal' };
                b[4][4] = { player: 'white', type: 'normal' };
                return b;
            }

            const getValidMoves = useCallback((brd, player, ghost = false) => {
                const moves = [];
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        if (brd[r][c].player) continue;
                        if (blackHoles.some(h => h.row === r && h.col === c)) continue;
                        if (ghost) {
                            moves.push({ row: r, col: c, flips: [] });
                        } else {
                            const flips = getFlips(brd, r, c, player);
                            if (flips.length > 0) moves.push({ row: r, col: c, flips });
                        }
                    }
                }
                return moves;
            }, [blackHoles]);

            function getFlips(brd, row, col, player) {
                const opp = player === 'black' ? 'white' : 'black';
                const allFlips = [];
                for (const [dr, dc] of DIRECTIONS) {
                    const flips = [];
                    let r = row + dr, c = col + dc;
                    while (r >= 0 && r < 8 && c >= 0 && c < 8) {
                        const cell = brd[r][c];
                        if (!cell.player) break;
                        if (cell.player === opp) flips.push({ row: r, col: c });
                        else { if (flips.length > 0) allFlips.push(...flips); break; }
                        r += dr; c += dc;
                    }
                }
                return allFlips;
            }

            function updateScores(brd) {
                let black = 0, white = 0;
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const cell = brd[r][c];
                        if (cell.player === 'black') black += cell.type === 'gold' ? 2 : 1;
                        else if (cell.player === 'white') white += cell.type === 'gold' ? 2 : 1;
                    }
                }
                setScores({ black, white });
                return { black, white };
            }

            const showToast = (msg, type = 'default') => {
                setToast({ msg, type });
                setTimeout(() => setToast(null), 2500);
            };

            const handleTurnEnd = useCallback((newBoard, justPlayed) => {
                const nextP = justPlayed === 'black' ? 'white' : 'black';
                const nextMoves = getValidMoves(newBoard, nextP);
                const currentMoves = getValidMoves(newBoard, justPlayed);

                // Decrease shields
                setShieldedDiscs(sd => sd.filter(s => s.turns > 1).map(s => ({ ...s, turns: s.turns - 1 })));

                if (nextMoves.length === 0 && currentMoves.length === 0) {
                    setTimeout(() => endGame(newBoard), 300);
                    return;
                }

                if (nextMoves.length === 0) {
                    const passPlayer = nextP === 'black' ? '‡∏Ñ‡∏∏‡∏ì' : 'AI';
                    setPassNotification({ player: passPlayer });
                    playSound('pass');
                    setTimeout(() => {
                        setPassNotification(null);
                        // ‡πÑ‡∏°‡πà‡∏™‡∏•‡∏±‡∏ö‡∏ï‡∏≤ - ‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡πÄ‡∏•‡πà‡∏ô‡∏ï‡πà‡∏≠
                    }, 1500);
                    return;
                }

                setCurrentPlayer(nextP);
            }, [getValidMoves]);

            const makeMove = useCallback((row, col, isAI = false) => {
                if (gameState !== 'playing') return;
                if (!isAI && currentPlayer === 'white') return;
                if (isAIThinking && !isAI) return;

                const player = currentPlayer;
                const newBoard = board.map(r => r.map(c => ({ ...c })));

                // Sniper mode
                if (sniperModeActive && !isAI) {
                    if (newBoard[row][col].player === 'white') {
                        newBoard[row][col].player = 'black';
                        setBoard(newBoard);
                        setSniperModeActive(false);
                        playSound('flip');
                        updateScores(newBoard);
                        setStats(s => ({ ...s, powerUpsUsed: s.powerUpsUsed + 1 }));
                        handleTurnEnd(newBoard, player);
                        return;
                    }
                    return;
                }

                const validMoves = getValidMoves(board, player, ghostModeActive);
                const move = validMoves.find(m => m.row === row && m.col === col);
                if (!move && !ghostModeActive) return;

                setGameHistory(h => [...h.slice(-10), { board: JSON.parse(JSON.stringify(board)), scores: { ...scores } }]);

                newBoard[row][col] = { player, type: 'normal' };
                playSound('place');

                const flips = ghostModeActive ? getFlips(board, row, col, player) : move.flips;
                flips.forEach(flip => {
                    if (!shieldedDiscs.some(s => s.row === flip.row && s.col === flip.col)) {
                        newBoard[flip.row][flip.col].player = player;
                    }
                });

                // Power-up pickup
                const key = `${row}-${col}`;
                if (boardPowerUps[key] && powerUps.length < 3 && !isAI) {
                    const picked = boardPowerUps[key];
                    setPowerUps(p => [...p, picked]);
                    setBoardPowerUps(bp => { const n = { ...bp }; delete n[key]; return n; });
                    playSound('powerup');
                    if (!seenItems.has('power_' + picked)) {
                        setSeenItems(s => new Set([...s, 'power_' + picked]));
                        showToast(`${POWER_UPS[picked].icon} ${POWER_UPS[picked].name}: ${POWER_UPS[picked].desc}`, 'power');
                    }
                }

                if (ghostModeActive) setGhostModeActive(false);

                setBoard(newBoard);
                updateScores(newBoard);

                // Combos
                if (flips.length >= 8) {
                    showToast('üî• TRIPLE FLIP! +1 Power-Up', 'default');
                    if (powerUps.length < 3 && player === 'black') {
                        const types = Object.keys(POWER_UPS);
                        setPowerUps(p => [...p, types[Math.floor(Math.random() * types.length)]]);
                    }
                    setStats(s => ({ ...s, combos: s.combos + 1 }));
                    playSound('combo');
                }

                if ((row === 0 || row === 7) && (col === 0 || col === 7)) {
                    newBoard[row][col].type = 'gold';
                    showToast('üèÜ CORNER MASTER! ‡∏´‡∏°‡∏≤‡∏Å‡∏ó‡∏≠‡∏á!', 'default');
                    setStats(s => ({ ...s, combos: s.combos + 1 }));
                    playSound('combo');
                    if (!seenItems.has('disc_gold')) {
                        setSeenItems(s => new Set([...s, 'disc_gold']));
                        setTimeout(() => showToast('ü•á ‡∏´‡∏°‡∏≤‡∏Å‡∏ó‡∏≠‡∏á: ‡∏ô‡∏±‡∏ö 2 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô!', 'info'), 2000);
                    }
                }

                // Spawn power-up
                if (gameMode === 'chaos' && Math.random() < 0.12) {
                    const empty = [];
                    for (let r = 0; r < 8; r++) {
                        for (let c = 0; c < 8; c++) {
                            if (!newBoard[r][c].player && !boardPowerUps[`${r}-${c}`] && !blackHoles.some(h => h.row === r && h.col === c)) {
                                empty.push({ r, c });
                            }
                        }
                    }
                    if (empty.length > 0) {
                        const cell = empty[Math.floor(Math.random() * empty.length)];
                        const types = Object.keys(POWER_UPS);
                        setBoardPowerUps(bp => ({ ...bp, [`${cell.r}-${cell.c}`]: types[Math.floor(Math.random() * types.length)] }));
                    }
                }

                const newTurn = turnCount + 1;
                setTurnCount(newTurn);

                // Random event
                if (gameMode === 'chaos' && newTurn >= nextEventIn) {
                    triggerEvent(newBoard);
                    setNextEventIn(newTurn + Math.floor(Math.random() * 4) + 5);
                }

                // Double turn
                if (doubleTurnActive && !isAI) {
                    setDoubleTurnActive(false);
                    const playerMoves = getValidMoves(newBoard, player);
                    if (playerMoves.length === 0) handleTurnEnd(newBoard, player);
                } else {
                    handleTurnEnd(newBoard, player);
                }

                playSound('flip');
            }, [board, currentPlayer, gameState, ghostModeActive, sniperModeActive, powerUps, boardPowerUps, blackHoles, shieldedDiscs, gameMode, turnCount, nextEventIn, doubleTurnActive, scores, getValidMoves, handleTurnEnd, seenItems]);

            function triggerEvent(brd) {
                const types = Object.keys(EVENTS);
                const type = types[Math.floor(Math.random() * types.length)];
                setCurrentEvent(type);
                playSound('event');

                setTimeout(() => {
                    applyEvent(type, brd);
                    setCurrentEvent(null);
                    setStats(s => ({ ...s, eventsLived: s.eventsLived + 1 }));
                }, 2500);
            }

            function applyEvent(type, brd) {
                setScreenShake(true);
                setTimeout(() => setScreenShake(false), 500);

                const newBoard = brd.map(r => r.map(c => ({ ...c })));

                switch (type) {
                    case 'EARTHQUAKE':
                        const dir = DIRECTIONS[Math.floor(Math.random() * DIRECTIONS.length)];
                        const temp = Array(8).fill(null).map(() => Array(8).fill(null).map(() => ({ player: null, type: 'normal' })));
                        for (let r = 0; r < 8; r++) {
                            for (let c = 0; c < 8; c++) {
                                if (newBoard[r][c].player) {
                                    const nr = Math.max(0, Math.min(7, r + dir[0]));
                                    const nc = Math.max(0, Math.min(7, c + dir[1]));
                                    if (!temp[nr][nc].player) temp[nr][nc] = { ...newBoard[r][c] };
                                    else temp[r][c] = { ...newBoard[r][c] };
                                }
                            }
                        }
                        setBoard(temp);
                        updateScores(temp);
                        break;

                    case 'BLACKHOLE':
                        const holes = [];
                        let att = 0;
                        while (holes.length < 4 && att < 50) {
                            const r = Math.floor(Math.random() * 8);
                            const c = Math.floor(Math.random() * 8);
                            if (!holes.some(h => h.row === r && h.col === c) && !newBoard[r][c].player) {
                                holes.push({ row: r, col: c });
                            }
                            att++;
                        }
                        setBlackHoles(h => [...h, ...holes]);
                        break;

                    case 'RAINBOW':
                        const discs = [];
                        for (let r = 0; r < 8; r++) {
                            for (let c = 0; c < 8; c++) {
                                if (newBoard[r][c].player && newBoard[r][c].type === 'normal') {
                                    discs.push({ r, c });
                                }
                            }
                        }
                        for (let i = 0; i < Math.min(5, discs.length); i++) {
                            const idx = Math.floor(Math.random() * discs.length);
                            const d = discs.splice(idx, 1)[0];
                            newBoard[d.r][d.c].type = 'gold';
                        }
                        setBoard(newBoard);
                        updateScores(newBoard);
                        break;

                    case 'TIMEWARP':
                        if (gameHistory.length >= 3) {
                            const past = gameHistory[gameHistory.length - 3];
                            setBoard(past.board);
                            setScores(past.scores);
                            setGameHistory(h => h.slice(0, -3));
                        }
                        break;

                    case 'MIRROR':
                        for (let r = 0; r < 8; r++) {
                            for (let c = 0; c < 4; c++) {
                                const t = newBoard[r][c];
                                newBoard[r][c] = newBoard[r][7 - c];
                                newBoard[r][7 - c] = t;
                            }
                        }
                        setBoard(newBoard);
                        break;

                    case 'CHAOS':
                        const all = [];
                        for (let r = 0; r < 8; r++) {
                            for (let c = 0; c < 8; c++) {
                                if (newBoard[r][c].player) all.push({ r, c });
                            }
                        }
                        for (let i = 0; i < Math.min(3, Math.floor(all.length / 2)); i++) {
                            if (all.length >= 2) {
                                const aIdx = Math.floor(Math.random() * all.length);
                                const a = all.splice(aIdx, 1)[0];
                                const bIdx = Math.floor(Math.random() * all.length);
                                const b = all.splice(bIdx, 1)[0];
                                const t = { ...newBoard[a.r][a.c] };
                                newBoard[a.r][a.c] = { ...newBoard[b.r][b.c] };
                                newBoard[b.r][b.c] = t;
                            }
                        }
                        setBoard(newBoard);
                        updateScores(newBoard);
                        break;
                }
            }

            function usePowerUp(type) {
                if (currentPlayer === 'white' || isAIThinking) return;

                switch (type) {
                    case 'BOMB': setSelectedPowerUp('BOMB'); break;
                    case 'SWAP':
                        const nb = board.map(r => r.map(c => ({
                            ...c,
                            player: c.player === 'black' ? 'white' : c.player === 'white' ? 'black' : null
                        })));
                        setBoard(nb);
                        updateScores(nb);
                        setPowerUps(p => { const i = p.indexOf(type); return p.filter((_, j) => j !== i); });
                        playSound('powerup');
                        setStats(s => ({ ...s, powerUpsUsed: s.powerUpsUsed + 1 }));
                        break;
                    case 'SHIELD': setSelectedPowerUp('SHIELD'); break;
                    case 'DOUBLE':
                        setDoubleTurnActive(true);
                        setPowerUps(p => { const i = p.indexOf(type); return p.filter((_, j) => j !== i); });
                        playSound('powerup');
                        setStats(s => ({ ...s, powerUpsUsed: s.powerUpsUsed + 1 }));
                        break;
                    case 'GHOST':
                        setGhostModeActive(true);
                        setPowerUps(p => { const i = p.indexOf(type); return p.filter((_, j) => j !== i); });
                        playSound('powerup');
                        setStats(s => ({ ...s, powerUpsUsed: s.powerUpsUsed + 1 }));
                        break;
                    case 'SNIPER':
                        setSniperModeActive(true);
                        setPowerUps(p => { const i = p.indexOf(type); return p.filter((_, j) => j !== i); });
                        setStats(s => ({ ...s, powerUpsUsed: s.powerUpsUsed + 1 }));
                        break;
                }
            }

            const handleCellClick = (row, col) => {
                if (selectedPowerUp === 'BOMB') {
                    const nb = board.map(r => r.map(c => ({ ...c })));
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            const nr = row + dr, nc = col + dc;
                            if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
                                nb[nr][nc] = { player: null, type: 'normal' };
                            }
                        }
                    }
                    setBoard(nb);
                    updateScores(nb);
                    setSelectedPowerUp(null);
                    setPowerUps(p => { const i = p.indexOf('BOMB'); return p.filter((_, j) => j !== i); });
                    playSound('powerup');
                    setScreenShake(true);
                    setTimeout(() => setScreenShake(false), 500);
                    setStats(s => ({ ...s, powerUpsUsed: s.powerUpsUsed + 1 }));
                    return;
                }

                if (selectedPowerUp === 'SHIELD') {
                    if (board[row][col].player === 'black') {
                        setShieldedDiscs(sd => [...sd, { row, col, turns: 3 }]);
                        setSelectedPowerUp(null);
                        setPowerUps(p => { const i = p.indexOf('SHIELD'); return p.filter((_, j) => j !== i); });
                        playSound('powerup');
                        setStats(s => ({ ...s, powerUpsUsed: s.powerUpsUsed + 1 }));
                    }
                    return;
                }

                makeMove(row, col);
            };

            // AI
            useEffect(() => {
                if (currentPlayer === 'white' && gameState === 'playing' && !isAIThinking && !passNotification && !currentEvent) {
                    setIsAIThinking(true);
                    const time = difficulty === 'hard' ? 1200 : difficulty === 'medium' ? 700 : 400;

                    setTimeout(() => {
                        const moves = getValidMoves(board, 'white');
                        if (moves.length === 0) {
                            const playerMoves = getValidMoves(board, 'black');
                            if (playerMoves.length === 0) {
                                endGame(board);
                            } else {
                                setPassNotification({ player: 'AI' });
                                playSound('pass');
                                setTimeout(() => {
                                    setPassNotification(null);
                                    setCurrentPlayer('black');
                                }, 1500);
                            }
                            setIsAIThinking(false);
                            return;
                        }

                        let move;
                        if (difficulty === 'easy') {
                            move = moves[Math.floor(Math.random() * moves.length)];
                        } else if (difficulty === 'medium') {
                            move = moves.reduce((best, m) => {
                                let sc = m.flips.length;
                                if ((m.row === 0 || m.row === 7) && (m.col === 0 || m.col === 7)) sc += 10;
                                if (m.row === 0 || m.row === 7 || m.col === 0 || m.col === 7) sc += 2;
                                return sc > (best.score || 0) ? { ...m, score: sc } : best;
                            }, moves[0]);
                        } else {
                            move = minimaxMove(board, 4);
                        }

                        if (move) makeMove(move.row, move.col, true);
                        setIsAIThinking(false);
                    }, time);
                }
            }, [currentPlayer, gameState, board, difficulty, isAIThinking, passNotification, currentEvent, getValidMoves, makeMove]);

            function minimaxMove(brd, depth) {
                const moves = getValidMoves(brd, 'white');
                if (moves.length === 0) return null;
                let best = moves[0], bestScore = -Infinity;
                for (const m of moves) {
                    const nb = applyMv(brd, m, 'white');
                    let sc = minimax(nb, depth - 1, -Infinity, Infinity, false);
                    if ((m.row === 0 || m.row === 7) && (m.col === 0 || m.col === 7)) sc += 50;
                    if (sc > bestScore) { bestScore = sc; best = m; }
                }
                return best;
            }

            function minimax(brd, depth, alpha, beta, isMax) {
                if (depth === 0) return evalBoard(brd);
                const player = isMax ? 'white' : 'black';
                const moves = getValidMoves(brd, player);
                if (moves.length === 0) return evalBoard(brd);

                if (isMax) {
                    let max = -Infinity;
                    for (const m of moves) {
                        const nb = applyMv(brd, m, player);
                        max = Math.max(max, minimax(nb, depth - 1, alpha, beta, false));
                        alpha = Math.max(alpha, max);
                        if (beta <= alpha) break;
                    }
                    return max;
                } else {
                    let min = Infinity;
                    for (const m of moves) {
                        const nb = applyMv(brd, m, player);
                        min = Math.min(min, minimax(nb, depth - 1, alpha, beta, true));
                        beta = Math.min(beta, min);
                        if (beta <= alpha) break;
                    }
                    return min;
                }
            }

            function applyMv(brd, move, player) {
                const nb = brd.map(r => r.map(c => ({ ...c })));
                nb[move.row][move.col] = { player, type: 'normal' };
                move.flips.forEach(f => { nb[f.row][f.col].player = player; });
                return nb;
            }

            function evalBoard(brd) {
                const weights = [
                    [100,-20,10,5,5,10,-20,100],
                    [-20,-50,-2,-2,-2,-2,-50,-20],
                    [10,-2,1,1,1,1,-2,10],
                    [5,-2,1,0,0,1,-2,5],
                    [5,-2,1,0,0,1,-2,5],
                    [10,-2,1,1,1,1,-2,10],
                    [-20,-50,-2,-2,-2,-2,-50,-20],
                    [100,-20,10,5,5,10,-20,100]
                ];
                let sc = 0;
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        if (brd[r][c].player === 'white') sc += weights[r][c];
                        else if (brd[r][c].player === 'black') sc -= weights[r][c];
                    }
                }
                return sc;
            }

            function endGame(brd) {
                const sc = { black: 0, white: 0 };
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const cell = brd[r][c];
                        if (cell.player === 'black') sc.black += cell.type === 'gold' ? 2 : 1;
                        else if (cell.player === 'white') sc.white += cell.type === 'gold' ? 2 : 1;
                    }
                }
                setGameState('ended');
                const winner = sc.black > sc.white ? 'player' : sc.white > sc.black ? 'ai' : 'draw';
                setResult({ winner, scores: sc, stats: { ...stats } });
                playSound(winner === 'player' ? 'victory' : 'defeat');
            }

            function startGame() {
                setBoard(initBoard());
                setCurrentPlayer('black');
                setGameState('playing');
                setScores({ black: 2, white: 2 });
                setPowerUps(gameMode === 'strategy' ? ['BOMB', 'SHIELD', 'DOUBLE'] : []);
                setBoardPowerUps({});
                setBlackHoles([]);
                setShieldedDiscs([]);
                setTurnCount(0);
                setNextEventIn(Math.floor(Math.random() * 4) + 5);
                setResult(null);
                setStats({ combos: 0, powerUpsUsed: 0, eventsLived: 0 });
                setGameHistory([]);
                setDoubleTurnActive(false);
                setGhostModeActive(false);
                setSniperModeActive(false);
                setSelectedPowerUp(null);
                setPassNotification(null);
                setCurrentEvent(null);
                setIsAIThinking(false);
            }

            const validMoves = currentPlayer === 'black' && !isAIThinking ? getValidMoves(board, 'black', ghostModeActive) : [];

            return (
                <div className={`min-h-screen min-h-[100dvh] p-2 flex flex-col ${screenShake ? 'screen-shake' : ''}`}>
                    <header className="text-center mb-2">
                        <h1 className="font-orbitron text-xl sm:text-3xl font-black text-cyan-400 neon-text tracking-wider">
                            OTHELLO TWIST
                        </h1>
                    </header>

                    {gameState === 'menu' ? (
                        <div className="flex-1 flex items-center justify-center">
                            <div className="w-full max-w-xs mx-auto">
                                <div className="bg-black/50 backdrop-blur-md rounded-2xl p-5 border border-cyan-500/30">
                                    <h2 className="font-orbitron text-lg text-white mb-3">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÇ‡∏´‡∏°‡∏î</h2>
                                    <div className="grid grid-cols-2 gap-2 mb-4">
                                        {['classic', 'chaos', 'strategy', 'speedrun'].map(mode => (
                                            <button key={mode} onClick={() => setGameMode(mode)} className={`btn-mode ${gameMode === mode ? 'active' : ''}`}>
                                                {mode === 'classic' && 'üéØ Classic'}
                                                {mode === 'chaos' && 'üå™Ô∏è Chaos'}
                                                {mode === 'strategy' && 'üß† Strategy'}
                                                {mode === 'speedrun' && '‚ö° Speed'}
                                            </button>
                                        ))}
                                    </div>
                                    <h2 className="font-orbitron text-lg text-white mb-3">‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏Å</h2>
                                    <div className="flex justify-center gap-2 mb-5">
                                        {['easy', 'medium', 'hard'].map(diff => (
                                            <button key={diff} onClick={() => setDifficulty(diff)} className={`btn-mode ${difficulty === diff ? 'active' : ''}`}>
                                                {diff === 'easy' && 'üòä ‡∏á‡πà‡∏≤‡∏¢'}
                                                {diff === 'medium' && 'üòê ‡∏Å‡∏•‡∏≤‡∏á'}
                                                {diff === 'hard' && 'üòà ‡∏¢‡∏≤‡∏Å'}
                                            </button>
                                        ))}
                                    </div>
                                    <button onClick={startGame} className="btn-neon w-full mb-3">üéÆ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°</button>
                                    <div className="text-left text-gray-400 text-xs space-y-1">
                                        <p><strong className="text-cyan-400">Classic:</strong> Othello ‡∏î‡∏±‡πâ‡∏á‡πÄ‡∏î‡∏¥‡∏°</p>
                                        <p><strong className="text-cyan-400">Chaos:</strong> Power-Up + Random Event</p>
                                        <p><strong className="text-cyan-400">Strategy:</strong> ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏°‡∏µ Power-Up 3 ‡∏ä‡∏¥‡πâ‡∏ô</p>
                                        <p><strong className="text-cyan-400">Speed:</strong> Power-Up ‡πÄ‡∏¢‡∏≠‡∏∞!</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    ) : (
                        <div className="flex-1 flex flex-col max-w-md mx-auto w-full">
                            <div className="flex justify-between items-center mb-2">
                                <div className="score-card">
                                    <div className="flex items-center gap-2">
                                        <div className="w-5 h-5 sm:w-6 sm:h-6 rounded-full bg-gradient-to-br from-gray-700 to-black"></div>
                                        <div>
                                            <div className="text-[9px] text-gray-400">‡∏Ñ‡∏∏‡∏ì</div>
                                            <div className="score-value text-cyan-400">{scores.black}</div>
                                        </div>
                                    </div>
                                </div>

                                <div className={`turn-indicator ${currentPlayer === 'black' ? 'player-turn' : 'ai-turn'}`}>
                                    {isAIThinking ? (
                                        <div className="flex items-center gap-2">
                                            <span className="text-white text-xs">AI</span>
                                            <div className="ai-thinking"><span></span><span></span><span></span></div>
                                        </div>
                                    ) : (
                                        <span className="text-white font-medium text-xs">
                                            {currentPlayer === 'black' ? 'üéÆ ‡∏ï‡∏≤‡∏Ñ‡∏∏‡∏ì' : 'ü§ñ AI'}
                                        </span>
                                    )}
                                </div>

                                <div className="score-card">
                                    <div className="flex items-center gap-2">
                                        <div>
                                            <div className="text-[9px] text-gray-400">AI</div>
                                            <div className="score-value text-pink-400">{scores.white}</div>
                                        </div>
                                        <div className="w-5 h-5 sm:w-6 sm:h-6 rounded-full bg-gradient-to-br from-white to-gray-300"></div>
                                    </div>
                                </div>
                            </div>

                            {gameMode === 'chaos' && (
                                <div className="text-center mb-1">
                                    <span className="text-yellow-400 text-xs">‚ö†Ô∏è Event ‡πÉ‡∏ô {Math.max(0, nextEventIn - turnCount)} ‡∏ï‡∏≤</span>
                                </div>
                            )}

                            <div className="flex flex-wrap justify-center gap-1 mb-1 min-h-[20px]">
                                {doubleTurnActive && <span className="bg-yellow-500/20 text-yellow-400 px-2 py-0.5 rounded-full text-xs">‚ö° Double!</span>}
                                {ghostModeActive && <span className="bg-purple-500/20 text-purple-400 px-2 py-0.5 rounded-full text-xs">üëª Ghost!</span>}
                                {sniperModeActive && <span className="bg-red-500/20 text-red-400 px-2 py-0.5 rounded-full text-xs">üéØ ‡∏Ñ‡∏•‡∏¥‡∏Å‡∏´‡∏°‡∏≤‡∏Å‡∏Ç‡∏≤‡∏ß!</span>}
                                {selectedPowerUp && <span className="bg-cyan-500/20 text-cyan-400 px-2 py-0.5 rounded-full text-xs">{POWER_UPS[selectedPowerUp].icon} ‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á</span>}
                            </div>

                            <div className="flex justify-center mb-2 px-1">
                                <div className="game-board w-full max-w-[min(88vw,360px)]">
                                    {board.map((row, ri) => row.map((cell, ci) => {
                                        const isValid = validMoves.some(m => m.row === ri && m.col === ci);
                                        const isHole = blackHoles.some(h => h.row === ri && h.col === ci);
                                        const pu = boardPowerUps[`${ri}-${ci}`];
                                        const isShield = shieldedDiscs.some(s => s.row === ri && s.col === ci);

                                        return (
                                            <div
                                                key={`${ri}-${ci}`}
                                                className={`cell ${cell.player ? 'has-disc' : ''} ${isValid ? 'valid-move' : ''} ${isHole ? 'black-hole' : ''}`}
                                                onClick={() => handleCellClick(ri, ci)}
                                            >
                                                {cell.player && (
                                                    <div className={`disc disc-${cell.player} ${cell.type === 'gold' ? 'disc-gold' : ''} ${isShield ? 'disc-shielded' : ''}`}></div>
                                                )}
                                                {pu && !cell.player && <span className="power-up-cell">{POWER_UPS[pu].icon}</span>}
                                            </div>
                                        );
                                    }))}
                                </div>
                            </div>

                            {gameMode !== 'classic' && (
                                <div className="flex justify-center items-center gap-2 mb-2">
                                    <span className="text-gray-400 text-xs">Power-Ups:</span>
                                    {[0, 1, 2].map(i => (
                                        <div
                                            key={i}
                                            className={`power-up-slot ${powerUps[i] && selectedPowerUp === powerUps[i] ? 'selected' : ''}`}
                                            onClick={() => powerUps[i] && usePowerUp(powerUps[i])}
                                        >
                                            {powerUps[i] ? POWER_UPS[powerUps[i]].icon : ''}
                                        </div>
                                    ))}
                                </div>
                            )}

                            <div className="flex justify-center gap-3 mt-auto pb-2">
                                <button onClick={startGame} className="btn-neon">üîÑ ‡πÉ‡∏´‡∏°‡πà</button>
                                <button onClick={() => setGameState('menu')} className="btn-neon" style={{ borderColor: '#ff00ff', color: '#ff00ff' }}>üè† ‡πÄ‡∏°‡∏ô‡∏π</button>
                            </div>
                        </div>
                    )}

                    {gameState === 'playing' && gameMode !== 'classic' && (
                        <button className="help-btn" onClick={() => setShowHelp(true)}>‚ùì</button>
                    )}

                    {showHelp && (
                        <>
                            <div className="popup-overlay" onClick={() => setShowHelp(false)}></div>
                            <div className="info-popup" style={{ width: '90%', maxWidth: '380px' }}>
                                <h2 className="font-orbitron text-lg text-cyan-400 mb-3">üìñ ‡∏Ñ‡∏π‡πà‡∏°‡∏∑‡∏≠</h2>
                                <div className="text-left mb-3">
                                    <h3 className="text-yellow-400 font-bold mb-1 text-sm">üí´ Power-Ups</h3>
                                    <div className="space-y-1 text-xs text-gray-300">
                                        {Object.entries(POWER_UPS).map(([k, v]) => (
                                            <p key={k}>{v.icon} <strong>{v.name}:</strong> {v.desc}</p>
                                        ))}
                                    </div>
                                </div>
                                <div className="text-left mb-3">
                                    <h3 className="text-pink-400 font-bold mb-1 text-sm">üåÄ Random Events</h3>
                                    <div className="space-y-1 text-xs text-gray-300">
                                        {Object.entries(EVENTS).map(([k, v]) => (
                                            <p key={k}>{v.icon} <strong>{v.name}:</strong> {v.desc}</p>
                                        ))}
                                    </div>
                                </div>
                                <div className="text-left mb-3">
                                    <h3 className="text-green-400 font-bold mb-1 text-sm">üé® ‡∏´‡∏°‡∏≤‡∏Å‡∏û‡∏¥‡πÄ‡∏®‡∏©</h3>
                                    <div className="text-xs text-gray-300">
                                        <p>ü•á <strong>‡∏´‡∏°‡∏≤‡∏Å‡∏ó‡∏≠‡∏á:</strong> ‡∏ô‡∏±‡∏ö 2 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô (‡πÑ‡∏î‡πâ‡∏à‡∏≤‡∏Å‡∏¢‡∏∂‡∏î‡∏°‡∏∏‡∏° ‡∏´‡∏£‡∏∑‡∏≠ Rainbow Event)</p>
                                    </div>
                                </div>
                                <button onClick={() => setShowHelp(false)} className="btn-neon text-xs">‡∏õ‡∏¥‡∏î</button>
                            </div>
                        </>
                    )}

                    {currentEvent && (
                        <>
                            <div className="popup-overlay"></div>
                            <div className="event-popup">
                                <div className="event-icon">{EVENTS[currentEvent].icon}</div>
                                <h2 className="font-orbitron text-xl text-pink-400 neon-text-magenta mb-2">{EVENTS[currentEvent].name}</h2>
                                <p className="text-white text-sm">{EVENTS[currentEvent].desc}</p>
                            </div>
                        </>
                    )}

                    {passNotification && (
                        <>
                            <div className="popup-overlay"></div>
                            <div className="pass-popup">
                                <div className="text-3xl mb-2">‚è≠Ô∏è</div>
                                <h2 className="font-orbitron text-lg text-yellow-400 mb-1">PASS!</h2>
                                <p className="text-white text-sm">{passNotification.player} ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ó‡∏µ‡πà‡∏ß‡∏≤‡∏á - ‡∏Ç‡πâ‡∏≤‡∏°‡∏ï‡∏≤</p>
                            </div>
                        </>
                    )}

                    {toast && (
                        <div className={`toast ${toast.type === 'info' ? 'info' : toast.type === 'power' ? 'power' : ''}`}>
                            {toast.msg}
                        </div>
                    )}

                    {result && (
                        <>
                            <div className="popup-overlay"></div>
                            <div className={`result-screen ${result.winner === 'player' ? 'victory' : 'defeat'}`}>
                                <div className="text-4xl mb-2">
                                    {result.winner === 'player' ? 'üéâ' : result.winner === 'ai' ? 'üò¢' : 'ü§ù'}
                                </div>
                                <h2 className={`font-orbitron text-2xl mb-3 ${result.winner === 'player' ? 'text-cyan-400 neon-text' : 'text-pink-400 neon-text-magenta'}`}>
                                    {result.winner === 'player' ? 'VICTORY!' : result.winner === 'ai' ? 'DEFEAT' : 'DRAW'}
                                </h2>
                                <div className="text-white text-xl mb-3">{result.scores.black} - {result.scores.white}</div>
                                {gameMode !== 'classic' && (
                                    <div className="text-left bg-black/30 rounded-lg p-2 mb-3 text-xs">
                                        <p className="text-gray-300">Combo: {result.stats.combos} | Power-Up: {result.stats.powerUpsUsed} | Event: {result.stats.eventsLived}</p>
                                    </div>
                                )}
                                <div className="flex gap-2 justify-center">
                                    <button onClick={startGame} className="btn-neon text-xs">üîÑ ‡πÄ‡∏•‡πà‡∏ô‡∏≠‡∏µ‡∏Å</button>
                                    <button onClick={() => { setResult(null); setGameState('menu'); }} className="btn-neon text-xs" style={{ borderColor: '#ff00ff', color: '#ff00ff' }}>üè† ‡πÄ‡∏°‡∏ô‡∏π</button>
                                </div>
                            </div>
                        </>
                    )}
                </div>
            );
        }

        ReactDOM.createRoot(document.getElementById('app')).render(<OthelloTwist />);
    </script>
</body>
</html>
