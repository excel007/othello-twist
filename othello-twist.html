<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Othello Twist - ‡πÄ‡∏Å‡∏°‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÉ‡∏Ñ‡∏£</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Kanit:wght@300;400;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --neon-cyan: #00f5ff;
            --neon-magenta: #ff00ff;
            --neon-yellow: #ffff00;
            --dark-bg: #0a0a1a;
            --darker-bg: #050510;
            --board-dark: #1a472a;
            --board-light: #2d5a3d;
        }

        body {
            font-family: 'Kanit', sans-serif;
            background: var(--dark-bg);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .font-orbitron {
            font-family: 'Orbitron', monospace;
        }

        /* Animated Background */
        .animated-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background: 
                radial-gradient(ellipse at 20% 80%, rgba(0, 245, 255, 0.1) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 20%, rgba(255, 0, 255, 0.1) 0%, transparent 50%),
                radial-gradient(ellipse at 50% 50%, rgba(255, 255, 0, 0.05) 0%, transparent 50%),
                var(--darker-bg);
        }

        .grid-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background-image: 
                linear-gradient(rgba(0, 245, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 245, 255, 0.03) 1px, transparent 1px);
            background-size: 50px 50px;
            animation: gridMove 20s linear infinite;
        }

        @keyframes gridMove {
            0% { transform: translate(0, 0); }
            100% { transform: translate(50px, 50px); }
        }

        /* Neon Text Effects */
        .neon-text {
            text-shadow: 
                0 0 5px var(--neon-cyan),
                0 0 10px var(--neon-cyan),
                0 0 20px var(--neon-cyan),
                0 0 40px var(--neon-cyan);
        }

        .neon-text-magenta {
            text-shadow: 
                0 0 5px var(--neon-magenta),
                0 0 10px var(--neon-magenta),
                0 0 20px var(--neon-magenta);
        }

        /* Game Board */
        .game-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 2px;
            padding: 8px;
            background: linear-gradient(135deg, #0d3320 0%, #1a472a 50%, #0d3320 100%);
            border-radius: 12px;
            box-shadow: 
                0 0 30px rgba(0, 245, 255, 0.3),
                inset 0 0 60px rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(0, 245, 255, 0.3);
        }

        .cell {
            aspect-ratio: 1;
            background: linear-gradient(135deg, #2d5a3d 0%, #1a472a 100%);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        .cell:hover:not(.has-disc) {
            background: linear-gradient(135deg, #3d7a5d 0%, #2a5a3a 100%);
            box-shadow: inset 0 0 20px rgba(0, 245, 255, 0.2);
        }

        .cell.valid-move::after {
            content: '';
            position: absolute;
            width: 30%;
            height: 30%;
            background: rgba(0, 245, 255, 0.5);
            border-radius: 50%;
            animation: pulse 1.5s ease-in-out infinite;
        }

        .cell.black-hole {
            background: radial-gradient(circle, #000 0%, #1a0a2e 50%, #000 100%);
            animation: blackHolePulse 2s ease-in-out infinite;
        }

        .cell.frozen {
            background: linear-gradient(135deg, #4a9eff 0%, #2d5a8d 100%);
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.3); opacity: 0.8; }
        }

        @keyframes blackHolePulse {
            0%, 100% { box-shadow: inset 0 0 20px #ff00ff; }
            50% { box-shadow: inset 0 0 40px #ff00ff; }
        }

        /* Discs */
        .disc {
            width: 80%;
            height: 80%;
            border-radius: 50%;
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            position: relative;
        }

        .disc-black {
            background: linear-gradient(145deg, #2a2a2a 0%, #0a0a0a 100%);
            box-shadow: 
                inset 3px 3px 6px rgba(255, 255, 255, 0.1),
                inset -3px -3px 6px rgba(0, 0, 0, 0.8),
                0 4px 8px rgba(0, 0, 0, 0.5);
        }

        .disc-white {
            background: linear-gradient(145deg, #ffffff 0%, #d0d0d0 100%);
            box-shadow: 
                inset 3px 3px 6px rgba(255, 255, 255, 0.8),
                inset -3px -3px 6px rgba(0, 0, 0, 0.2),
                0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .disc-gold {
            background: linear-gradient(145deg, #ffd700 0%, #b8860b 100%);
            box-shadow: 
                0 0 15px rgba(255, 215, 0, 0.6),
                inset 2px 2px 4px rgba(255, 255, 255, 0.5);
            animation: goldGlow 2s ease-in-out infinite;
        }

        .disc-diamond {
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.9) 0%, rgba(200, 230, 255, 0.8) 100%);
            box-shadow: 
                0 0 20px rgba(0, 245, 255, 0.8),
                inset 0 0 10px rgba(255, 255, 255, 0.9);
            animation: diamondSparkle 1.5s ease-in-out infinite;
        }

        .disc-fire {
            background: linear-gradient(145deg, #ff4500 0%, #8b0000 100%);
            box-shadow: 0 0 20px rgba(255, 69, 0, 0.8);
            animation: fireGlow 0.5s ease-in-out infinite alternate;
        }

        .disc-ice {
            background: linear-gradient(145deg, #87ceeb 0%, #4169e1 100%);
            box-shadow: 0 0 15px rgba(135, 206, 235, 0.6);
        }

        .disc-poison {
            background: linear-gradient(145deg, #9932cc 0%, #4b0082 100%);
            box-shadow: 0 0 15px rgba(153, 50, 204, 0.6);
            animation: poisonPulse 1s ease-in-out infinite;
        }

        .disc-shielded::after {
            content: 'üõ°Ô∏è';
            position: absolute;
            font-size: 0.6em;
            top: -5px;
            right: -5px;
        }

        @keyframes goldGlow {
            0%, 100% { box-shadow: 0 0 15px rgba(255, 215, 0, 0.6); }
            50% { box-shadow: 0 0 25px rgba(255, 215, 0, 0.9); }
        }

        @keyframes diamondSparkle {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.3); }
        }

        @keyframes fireGlow {
            0% { box-shadow: 0 0 15px rgba(255, 69, 0, 0.6); }
            100% { box-shadow: 0 0 25px rgba(255, 165, 0, 0.9); }
        }

        @keyframes poisonPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Flip Animation */
        .flipping {
            animation: flipDisc 0.5s ease-in-out;
        }

        @keyframes flipDisc {
            0% { transform: rotateY(0deg); }
            50% { transform: rotateY(90deg) scale(0.8); }
            100% { transform: rotateY(180deg); }
        }

        /* Power-up on board */
        .power-up-cell {
            position: absolute;
            font-size: 1.5em;
            animation: powerUpFloat 2s ease-in-out infinite;
            filter: drop-shadow(0 0 10px rgba(255, 255, 0, 0.8));
        }

        @keyframes powerUpFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }

        /* Power-up inventory */
        .power-up-slot {
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(0, 245, 255, 0.3);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .power-up-slot:hover {
            border-color: var(--neon-cyan);
            box-shadow: 0 0 15px rgba(0, 245, 255, 0.5);
            transform: scale(1.1);
        }

        .power-up-slot.selected {
            border-color: var(--neon-magenta);
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.7);
            animation: selectedPulse 1s ease-in-out infinite;
        }

        @keyframes selectedPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        /* Buttons */
        .btn-neon {
            padding: 12px 24px;
            background: transparent;
            border: 2px solid var(--neon-cyan);
            color: var(--neon-cyan);
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .btn-neon:hover {
            background: var(--neon-cyan);
            color: var(--dark-bg);
            box-shadow: 0 0 30px rgba(0, 245, 255, 0.5);
        }

        .btn-mode {
            padding: 8px 16px;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: rgba(255, 255, 255, 0.7);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-mode.active {
            background: rgba(0, 245, 255, 0.2);
            border-color: var(--neon-cyan);
            color: var(--neon-cyan);
        }

        /* Event Popup */
        .event-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: radial-gradient(ellipse at center, rgba(20, 0, 40, 0.98) 0%, rgba(10, 0, 20, 0.98) 100%);
            border: 3px solid var(--neon-magenta);
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            z-index: 1000;
            animation: popupAppear 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            box-shadow: 0 0 60px rgba(255, 0, 255, 0.5);
        }

        @keyframes popupAppear {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        .event-icon {
            font-size: 5em;
            margin-bottom: 20px;
            animation: eventIconBounce 0.5s ease-in-out infinite alternate;
        }

        @keyframes eventIconBounce {
            0% { transform: scale(1); }
            100% { transform: scale(1.1); }
        }

        /* Combo notification */
        .combo-popup {
            position: fixed;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.9) 0%, rgba(255, 165, 0, 0.9) 100%);
            color: #000;
            padding: 15px 40px;
            border-radius: 30px;
            font-family: 'Orbitron', monospace;
            font-weight: 900;
            font-size: 1.5em;
            z-index: 1000;
            animation: comboSlide 2s ease-out forwards;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
        }

        @keyframes comboSlide {
            0% { transform: translateX(-50%) translateY(-50px); opacity: 0; }
            20% { transform: translateX(-50%) translateY(0); opacity: 1; }
            80% { transform: translateX(-50%) translateY(0); opacity: 1; }
            100% { transform: translateX(-50%) translateY(-50px); opacity: 0; }
        }

        /* Score display */
        .score-card {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 15px 25px;
            backdrop-filter: blur(10px);
        }

        .score-value {
            font-family: 'Orbitron', monospace;
            font-size: 2.5em;
            font-weight: 900;
        }

        /* Tutorial tooltip */
        .tutorial-tip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid var(--neon-yellow);
            color: #fff;
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 0.9em;
            max-width: 200px;
            z-index: 100;
            animation: tipPulse 2s ease-in-out infinite;
        }

        @keyframes tipPulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 255, 0, 0.3); }
            50% { box-shadow: 0 0 20px rgba(255, 255, 0, 0.6); }
        }

        /* Shake animation */
        .screen-shake {
            animation: shake 0.5s ease-in-out;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }

        /* Turn indicator */
        .turn-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 30px;
            border: 2px solid;
        }

        .turn-indicator.player-turn {
            border-color: var(--neon-cyan);
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.3);
        }

        .turn-indicator.ai-turn {
            border-color: var(--neon-magenta);
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.3);
        }

        /* Thinking animation */
        .ai-thinking {
            display: flex;
            gap: 5px;
        }

        .ai-thinking span {
            width: 8px;
            height: 8px;
            background: var(--neon-magenta);
            border-radius: 50%;
            animation: thinking 1.4s ease-in-out infinite;
        }

        .ai-thinking span:nth-child(2) { animation-delay: 0.2s; }
        .ai-thinking span:nth-child(3) { animation-delay: 0.4s; }

        @keyframes thinking {
            0%, 100% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.5); opacity: 1; }
        }

        /* Particle effects */
        .particle {
            position: absolute;
            pointer-events: none;
            animation: particleFade 1s ease-out forwards;
        }

        @keyframes particleFade {
            0% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(0) translateY(-50px); }
        }

        /* Overlay */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 999;
            backdrop-filter: blur(5px);
        }

        /* Result screen */
        .result-screen {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(10, 10, 30, 0.98) 0%, rgba(5, 5, 15, 0.98) 100%);
            border-radius: 30px;
            padding: 50px;
            text-align: center;
            z-index: 1001;
            min-width: 400px;
            animation: resultAppear 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        .result-screen.victory {
            border: 3px solid var(--neon-cyan);
            box-shadow: 0 0 80px rgba(0, 245, 255, 0.5);
        }

        .result-screen.defeat {
            border: 3px solid var(--neon-magenta);
            box-shadow: 0 0 80px rgba(255, 0, 255, 0.5);
        }

        @keyframes resultAppear {
            0% { transform: translate(-50%, -50%) scale(0) rotate(-10deg); opacity: 0; }
            100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); opacity: 1; }
        }

        /* Mobile responsive */
        @media (max-width: 768px) {
            .game-board {
                width: 95vw;
                max-width: 400px;
            }

            .score-value {
                font-size: 1.8em;
            }

            .power-up-slot {
                width: 40px;
                height: 40px;
                font-size: 1.2em;
            }
        }
    </style>
</head>
<body>
    <div class="animated-bg"></div>
    <div class="grid-overlay"></div>

    <div id="app"></div>

    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useRef } = React;

        // Constants
        const BOARD_SIZE = 8;
        const DIRECTIONS = [
            [-1, -1], [-1, 0], [-1, 1],
            [0, -1],           [0, 1],
            [1, -1],  [1, 0],  [1, 1]
        ];

        const POWER_UPS = {
            BOMB: { icon: 'üí£', name: 'Bomb', desc: '‡∏£‡∏∞‡πÄ‡∏ö‡∏¥‡∏î‡∏´‡∏°‡∏≤‡∏Å 3√ó3' },
            SWAP: { icon: 'üîÑ', name: 'Swap', desc: '‡∏™‡∏•‡∏±‡∏ö‡∏™‡∏µ‡∏´‡∏°‡∏≤‡∏Å‡∏ó‡∏±‡πâ‡∏á‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô' },
            SHIELD: { icon: 'üõ°Ô∏è', name: 'Shield', desc: '‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏´‡∏°‡∏≤‡∏Å 1 ‡∏ï‡∏±‡∏ß' },
            DOUBLE: { icon: '‚ö°', name: 'Double Turn', desc: '‡πÄ‡∏î‡∏¥‡∏ô‡πÑ‡∏î‡πâ 2 ‡∏Ñ‡∏£‡∏±‡πâ‡∏á' },
            GHOST: { icon: 'üëª', name: 'Ghost', desc: '‡∏ß‡∏≤‡∏á‡∏´‡∏°‡∏≤‡∏Å‡∏ó‡∏µ‡πà‡πÑ‡∏´‡∏ô‡∏Å‡πá‡πÑ‡∏î‡πâ' },
            SNIPER: { icon: 'üéØ', name: 'Sniper', desc: '‡∏û‡∏•‡∏¥‡∏Å‡∏´‡∏°‡∏≤‡∏Å‡∏®‡∏±‡∏ï‡∏£‡∏π 1 ‡∏ï‡∏±‡∏ß' }
        };

        const EVENTS = {
            EARTHQUAKE: { icon: 'üåä', name: 'Earthquake', desc: '‡∏´‡∏°‡∏≤‡∏Å‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÄ‡∏•‡∏∑‡πà‡∏≠‡∏ô!' },
            BLACKHOLE: { icon: 'üï≥Ô∏è', name: 'Black Hole', desc: '‡πÄ‡∏Å‡∏¥‡∏î‡∏´‡∏•‡∏∏‡∏°‡∏î‡∏≥ 4 ‡∏ä‡πà‡∏≠‡∏á!' },
            RAINBOW: { icon: 'üåà', name: 'Rainbow', desc: '‡∏´‡∏°‡∏≤‡∏Å 5 ‡∏ï‡∏±‡∏ß‡∏Å‡∏•‡∏≤‡∏¢‡πÄ‡∏õ‡πá‡∏ô‡∏ó‡∏≠‡∏á!' },
            TIMEWARP: { icon: '‚è∞', name: 'Time Warp', desc: '‡∏¢‡πâ‡∏≠‡∏ô‡πÄ‡∏ß‡∏•‡∏≤ 3 ‡∏ï‡∏≤!' },
            MIRROR: { icon: 'üé≠', name: 'Mirror', desc: '‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô‡∏™‡∏∞‡∏ó‡πâ‡∏≠‡∏ô!' },
            CHAOS: { icon: 'üå™Ô∏è', name: 'Chaos', desc: '‡∏´‡∏°‡∏≤‡∏Å 6 ‡∏ï‡∏±‡∏ß‡∏™‡∏•‡∏±‡∏ö‡∏ó‡∏µ‡πà!' }
        };

        const DISC_TYPES = {
            NORMAL: 'normal',
            GOLD: 'gold',
            DIAMOND: 'diamond',
            FIRE: 'fire',
            ICE: 'ice',
            POISON: 'poison'
        };

        // Sound effects (using Web Audio API)
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx = null;

        const playSound = (type) => {
            if (!audioCtx) audioCtx = new AudioContext();
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            const sounds = {
                place: { freq: 440, duration: 0.1, type: 'sine' },
                flip: { freq: 660, duration: 0.15, type: 'sine' },
                powerup: { freq: 880, duration: 0.3, type: 'square' },
                combo: { freq: 1000, duration: 0.5, type: 'sawtooth' },
                event: { freq: 220, duration: 0.8, type: 'triangle' },
                victory: { freq: 523, duration: 1, type: 'sine' },
                defeat: { freq: 196, duration: 1, type: 'sine' }
            };

            const sound = sounds[type] || sounds.place;
            oscillator.type = sound.type;
            oscillator.frequency.setValueAtTime(sound.freq, audioCtx.currentTime);
            gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + sound.duration);
            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + sound.duration);
        };

        // Main Game Component
        function OthelloTwist() {
            // Game state
            const [board, setBoard] = useState(() => initializeBoard());
            const [currentPlayer, setCurrentPlayer] = useState('black');
            const [gameMode, setGameMode] = useState('chaos'); // classic, chaos, strategy, speedrun
            const [difficulty, setDifficulty] = useState('medium'); // easy, medium, hard
            const [gameState, setGameState] = useState('menu'); // menu, playing, ended
            const [scores, setScores] = useState({ black: 2, white: 2 });
            const [powerUps, setPowerUps] = useState([]);
            const [selectedPowerUp, setSelectedPowerUp] = useState(null);
            const [boardPowerUps, setBoardPowerUps] = useState({});
            const [blackHoles, setBlackHoles] = useState([]);
            const [frozenCells, setFrozenCells] = useState({});
            const [shieldedDiscs, setShieldedDiscs] = useState([]);
            const [turnCount, setTurnCount] = useState(0);
            const [nextEventIn, setNextEventIn] = useState(Math.floor(Math.random() * 4) + 5);
            const [currentEvent, setCurrentEvent] = useState(null);
            const [combo, setCombo] = useState(null);
            const [isAIThinking, setIsAIThinking] = useState(false);
            const [doubleTurnActive, setDoubleTurnActive] = useState(false);
            const [ghostModeActive, setGhostModeActive] = useState(false);
            const [sniperModeActive, setSniperModeActive] = useState(false);
            const [gameHistory, setGameHistory] = useState([]);
            const [screenShake, setScreenShake] = useState(false);
            const [result, setResult] = useState(null);
            const [stats, setStats] = useState({ combos: 0, powerUpsUsed: 0, eventsLived: 0 });

            const boardRef = useRef(null);

            // Initialize board
            function initializeBoard() {
                const newBoard = Array(BOARD_SIZE).fill(null).map(() => 
                    Array(BOARD_SIZE).fill(null).map(() => ({ player: null, type: DISC_TYPES.NORMAL }))
                );
                // Initial setup
                newBoard[3][3] = { player: 'white', type: DISC_TYPES.NORMAL };
                newBoard[3][4] = { player: 'black', type: DISC_TYPES.NORMAL };
                newBoard[4][3] = { player: 'black', type: DISC_TYPES.NORMAL };
                newBoard[4][4] = { player: 'white', type: DISC_TYPES.NORMAL };
                return newBoard;
            }

            // Get valid moves
            const getValidMoves = useCallback((board, player, ghost = false) => {
                const moves = [];
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        if (board[row][col].player) continue;
                        if (blackHoles.some(bh => bh.row === row && bh.col === col)) continue;
                        if (frozenCells[`${row}-${col}`]) continue;

                        if (ghost) {
                            moves.push({ row, col, flips: [] });
                        } else {
                            const flips = getFlips(board, row, col, player);
                            if (flips.length > 0) {
                                moves.push({ row, col, flips });
                            }
                        }
                    }
                }
                return moves;
            }, [blackHoles, frozenCells]);

            // Get flips for a move
            function getFlips(board, row, col, player) {
                const opponent = player === 'black' ? 'white' : 'black';
                const allFlips = [];

                for (const [dr, dc] of DIRECTIONS) {
                    const flips = [];
                    let r = row + dr;
                    let c = col + dc;

                    while (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE) {
                        const cell = board[r][c];
                        if (!cell.player) break;
                        if (cell.player === opponent) {
                            flips.push({ row: r, col: c });
                        } else {
                            if (flips.length > 0) {
                                allFlips.push(...flips);
                            }
                            break;
                        }
                        r += dr;
                        c += dc;
                    }
                }

                return allFlips;
            }

            // Make a move
            const makeMove = useCallback((row, col, isAI = false) => {
                if (gameState !== 'playing') return;
                if (!isAI && currentPlayer === 'white') return;
                if (isAIThinking && !isAI) return;

                const player = currentPlayer;
                const newBoard = board.map(r => r.map(c => ({ ...c })));

                // Check for sniper mode
                if (sniperModeActive && !isAI) {
                    if (newBoard[row][col].player === 'white') {
                        newBoard[row][col].player = 'black';
                        setBoard(newBoard);
                        setSniperModeActive(false);
                        playSound('flip');
                        updateScores(newBoard);
                        setStats(s => ({ ...s, powerUpsUsed: s.powerUpsUsed + 1 }));
                        switchTurn();
                        return;
                    }
                    return;
                }

                // Ghost mode - can place anywhere
                const validMoves = getValidMoves(board, player, ghostModeActive);
                const move = validMoves.find(m => m.row === row && m.col === col);

                if (!move && !ghostModeActive) return;

                // Save history for time warp
                setGameHistory(h => [...h.slice(-10), { board: JSON.parse(JSON.stringify(board)), scores: { ...scores } }]);

                // Place disc
                newBoard[row][col] = { player, type: DISC_TYPES.NORMAL };
                playSound('place');

                // Apply flips (not in ghost mode for empty cells)
                const flips = ghostModeActive ? getFlips(board, row, col, player) : move.flips;
                flips.forEach(flip => {
                    if (!shieldedDiscs.some(s => s.row === flip.row && s.col === flip.col)) {
                        // Check for poison disc
                        if (newBoard[flip.row][flip.col].type === DISC_TYPES.POISON) {
                            // Poison effect - flip 2 of the flipper's discs
                            let flipped = 0;
                            for (let r = 0; r < BOARD_SIZE && flipped < 2; r++) {
                                for (let c = 0; c < BOARD_SIZE && flipped < 2; c++) {
                                    if (newBoard[r][c].player === player && !(r === row && c === col)) {
                                        newBoard[r][c].player = player === 'black' ? 'white' : 'black';
                                        flipped++;
                                    }
                                }
                            }
                        }
                        newBoard[flip.row][flip.col].player = player;
                    }
                });

                // Check for power-up pickup
                const powerUpKey = `${row}-${col}`;
                if (boardPowerUps[powerUpKey] && powerUps.length < 3) {
                    setPowerUps(p => [...p, boardPowerUps[powerUpKey]]);
                    setBoardPowerUps(bp => {
                        const newBp = { ...bp };
                        delete newBp[powerUpKey];
                        return newBp;
                    });
                    playSound('powerup');
                }

                if (ghostModeActive) {
                    setGhostModeActive(false);
                }

                // Fire disc effect
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        if (newBoard[r][c].type === DISC_TYPES.FIRE && newBoard[r][c].player) {
                            const firePlayer = newBoard[r][c].player;
                            DIRECTIONS.forEach(([dr, dc]) => {
                                const nr = r + dr;
                                const nc = c + dc;
                                if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {
                                    if (newBoard[nr][nc].player && newBoard[nr][nc].player !== firePlayer) {
                                        if (!shieldedDiscs.some(s => s.row === nr && s.col === nc)) {
                                            newBoard[nr][nc].player = firePlayer;
                                        }
                                    }
                                }
                            });
                        }
                    }
                }

                setBoard(newBoard);
                updateScores(newBoard);

                // Check for combos
                checkCombos(flips.length, row, col, newBoard, player);

                // Spawn power-ups on board (chaos mode)
                if (gameMode === 'chaos' && Math.random() < 0.15) {
                    spawnPowerUp();
                }

                // Update turn count and check for events
                const newTurnCount = turnCount + 1;
                setTurnCount(newTurnCount);

                if (gameMode === 'chaos' && newTurnCount >= nextEventIn) {
                    triggerRandomEvent();
                    setNextEventIn(newTurnCount + Math.floor(Math.random() * 4) + 5);
                }

                // Check for double turn
                if (doubleTurnActive && !isAI) {
                    setDoubleTurnActive(false);
                    // Don't switch turn
                } else {
                    switchTurn();
                }

                playSound('flip');
            }, [board, currentPlayer, gameState, ghostModeActive, sniperModeActive, powerUps, boardPowerUps, blackHoles, frozenCells, shieldedDiscs, gameMode, turnCount, nextEventIn, doubleTurnActive, scores, getValidMoves]);

            // Switch turn
            const switchTurn = useCallback(() => {
                const nextPlayer = currentPlayer === 'black' ? 'white' : 'black';
                const nextMoves = getValidMoves(board, nextPlayer);
                
                if (nextMoves.length === 0) {
                    const currentMoves = getValidMoves(board, currentPlayer);
                    if (currentMoves.length === 0) {
                        // Game over
                        endGame();
                    }
                    // Skip turn
                    return;
                }

                setCurrentPlayer(nextPlayer);

                // Decrease frozen cells
                setFrozenCells(fc => {
                    const newFc = {};
                    Object.entries(fc).forEach(([key, turns]) => {
                        if (turns > 1) newFc[key] = turns - 1;
                    });
                    return newFc;
                });

                // Decrease shield
                setShieldedDiscs(sd => sd.filter(s => s.turns > 1).map(s => ({ ...s, turns: s.turns - 1 })));
            }, [currentPlayer, board, getValidMoves]);

            // Update scores
            function updateScores(newBoard) {
                let black = 0, white = 0;
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        const cell = newBoard[r][c];
                        if (cell.player === 'black') {
                            black += cell.type === DISC_TYPES.GOLD ? 2 : 1;
                        } else if (cell.player === 'white') {
                            white += cell.type === DISC_TYPES.GOLD ? 2 : 1;
                        }
                    }
                }
                setScores({ black, white });
            }

            // Check combos
            function checkCombos(flipsCount, row, col, newBoard, player) {
                // Triple Flip
                if (flipsCount >= 8) {
                    setCombo({ name: 'TRIPLE FLIP!', desc: '+1 Power-Up ‡∏™‡∏∏‡πà‡∏°' });
                    if (powerUps.length < 3) {
                        const powerUpTypes = Object.keys(POWER_UPS);
                        setPowerUps(p => [...p, powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)]]);
                    }
                    setStats(s => ({ ...s, combos: s.combos + 1 }));
                    playSound('combo');
                }

                // Corner Master
                if ((row === 0 || row === 7) && (col === 0 || col === 7)) {
                    newBoard[row][col].type = DISC_TYPES.GOLD;
                    setCombo({ name: 'CORNER MASTER!', desc: '‡∏´‡∏°‡∏≤‡∏Å‡∏°‡∏∏‡∏°‡πÄ‡∏õ‡πá‡∏ô‡∏ó‡∏≠‡∏á!' });
                    setStats(s => ({ ...s, combos: s.combos + 1 }));
                    playSound('combo');
                }
            }

            // Spawn power-up on board
            function spawnPowerUp() {
                const emptyCells = [];
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        if (!board[r][c].player && !boardPowerUps[`${r}-${c}`] && !blackHoles.some(bh => bh.row === r && bh.col === c)) {
                            emptyCells.push({ r, c });
                        }
                    }
                }
                if (emptyCells.length > 0) {
                    const cell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                    const powerUpTypes = Object.keys(POWER_UPS);
                    setBoardPowerUps(bp => ({
                        ...bp,
                        [`${cell.r}-${cell.c}`]: powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)]
                    }));
                }
            }

            // Trigger random event
            function triggerRandomEvent() {
                const eventTypes = Object.keys(EVENTS);
                const eventType = eventTypes[Math.floor(Math.random() * eventTypes.length)];
                setCurrentEvent(eventType);
                playSound('event');

                setTimeout(() => {
                    applyEvent(eventType);
                    setCurrentEvent(null);
                    setStats(s => ({ ...s, eventsLived: s.eventsLived + 1 }));
                }, 2500);
            }

            // Apply event effect
            function applyEvent(eventType) {
                setScreenShake(true);
                setTimeout(() => setScreenShake(false), 500);

                const newBoard = board.map(r => r.map(c => ({ ...c })));

                switch (eventType) {
                    case 'EARTHQUAKE':
                        // Shift all discs in random direction
                        const dir = DIRECTIONS[Math.floor(Math.random() * DIRECTIONS.length)];
                        const tempBoard = Array(BOARD_SIZE).fill(null).map(() => 
                            Array(BOARD_SIZE).fill(null).map(() => ({ player: null, type: DISC_TYPES.NORMAL }))
                        );
                        for (let r = 0; r < BOARD_SIZE; r++) {
                            for (let c = 0; c < BOARD_SIZE; c++) {
                                if (newBoard[r][c].player) {
                                    const nr = Math.max(0, Math.min(7, r + dir[0]));
                                    const nc = Math.max(0, Math.min(7, c + dir[1]));
                                    if (!tempBoard[nr][nc].player) {
                                        tempBoard[nr][nc] = { ...newBoard[r][c] };
                                    }
                                }
                            }
                        }
                        setBoard(tempBoard);
                        updateScores(tempBoard);
                        break;

                    case 'BLACKHOLE':
                        // Create 4 black holes
                        const holes = [];
                        while (holes.length < 4) {
                            const r = Math.floor(Math.random() * BOARD_SIZE);
                            const c = Math.floor(Math.random() * BOARD_SIZE);
                            if (!holes.some(h => h.row === r && h.col === c) && !newBoard[r][c].player) {
                                holes.push({ row: r, col: c });
                            }
                        }
                        setBlackHoles(h => [...h, ...holes]);
                        break;

                    case 'RAINBOW':
                        // Turn 5 random discs to gold
                        const discs = [];
                        for (let r = 0; r < BOARD_SIZE; r++) {
                            for (let c = 0; c < BOARD_SIZE; c++) {
                                if (newBoard[r][c].player && newBoard[r][c].type === DISC_TYPES.NORMAL) {
                                    discs.push({ r, c });
                                }
                            }
                        }
                        for (let i = 0; i < Math.min(5, discs.length); i++) {
                            const idx = Math.floor(Math.random() * discs.length);
                            const disc = discs.splice(idx, 1)[0];
                            newBoard[disc.r][disc.c].type = DISC_TYPES.GOLD;
                        }
                        setBoard(newBoard);
                        updateScores(newBoard);
                        break;

                    case 'TIMEWARP':
                        // Go back 3 turns
                        if (gameHistory.length >= 3) {
                            const pastState = gameHistory[gameHistory.length - 3];
                            setBoard(pastState.board);
                            setScores(pastState.scores);
                            setGameHistory(h => h.slice(0, -3));
                        }
                        break;

                    case 'MIRROR':
                        // Mirror board horizontally
                        for (let r = 0; r < BOARD_SIZE; r++) {
                            for (let c = 0; c < BOARD_SIZE / 2; c++) {
                                const temp = newBoard[r][c];
                                newBoard[r][c] = newBoard[r][BOARD_SIZE - 1 - c];
                                newBoard[r][BOARD_SIZE - 1 - c] = temp;
                            }
                        }
                        setBoard(newBoard);
                        break;

                    case 'CHAOS':
                        // Swap 6 random disc positions
                        const allDiscs = [];
                        for (let r = 0; r < BOARD_SIZE; r++) {
                            for (let c = 0; c < BOARD_SIZE; c++) {
                                if (newBoard[r][c].player) {
                                    allDiscs.push({ r, c, disc: { ...newBoard[r][c] } });
                                }
                            }
                        }
                        for (let i = 0; i < Math.min(6, allDiscs.length); i += 2) {
                            if (i + 1 < allDiscs.length) {
                                const a = allDiscs[Math.floor(Math.random() * allDiscs.length)];
                                const b = allDiscs[Math.floor(Math.random() * allDiscs.length)];
                                if (a !== b) {
                                    const temp = newBoard[a.r][a.c];
                                    newBoard[a.r][a.c] = newBoard[b.r][b.c];
                                    newBoard[b.r][b.c] = temp;
                                }
                            }
                        }
                        setBoard(newBoard);
                        updateScores(newBoard);
                        break;
                }
            }

            // Use power-up
            function usePowerUp(type) {
                if (currentPlayer === 'white' || isAIThinking) return;

                switch (type) {
                    case 'BOMB':
                        // Will apply on next click
                        setSelectedPowerUp('BOMB');
                        break;

                    case 'SWAP':
                        const newBoard = board.map(r => r.map(c => ({
                            ...c,
                            player: c.player === 'black' ? 'white' : c.player === 'white' ? 'black' : null
                        })));
                        setBoard(newBoard);
                        updateScores(newBoard);
                        setPowerUps(p => p.filter((_, i) => i !== p.indexOf(type)));
                        playSound('powerup');
                        setStats(s => ({ ...s, powerUpsUsed: s.powerUpsUsed + 1 }));
                        break;

                    case 'SHIELD':
                        setSelectedPowerUp('SHIELD');
                        break;

                    case 'DOUBLE':
                        setDoubleTurnActive(true);
                        setPowerUps(p => p.filter((_, i) => i !== p.indexOf(type)));
                        playSound('powerup');
                        setStats(s => ({ ...s, powerUpsUsed: s.powerUpsUsed + 1 }));
                        break;

                    case 'GHOST':
                        setGhostModeActive(true);
                        setPowerUps(p => p.filter((_, i) => i !== p.indexOf(type)));
                        playSound('powerup');
                        setStats(s => ({ ...s, powerUpsUsed: s.powerUpsUsed + 1 }));
                        break;

                    case 'SNIPER':
                        setSniperModeActive(true);
                        setPowerUps(p => p.filter((_, i) => i !== p.indexOf(type)));
                        setStats(s => ({ ...s, powerUpsUsed: s.powerUpsUsed + 1 }));
                        break;
                }
            }

            // Handle cell click with power-up
            const handleCellClick = (row, col) => {
                if (selectedPowerUp === 'BOMB') {
                    // Bomb effect - clear 3x3 area
                    const newBoard = board.map(r => r.map(c => ({ ...c })));
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            const nr = row + dr;
                            const nc = col + dc;
                            if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {
                                newBoard[nr][nc] = { player: null, type: DISC_TYPES.NORMAL };
                            }
                        }
                    }
                    setBoard(newBoard);
                    updateScores(newBoard);
                    setSelectedPowerUp(null);
                    setPowerUps(p => p.filter((_, i) => i !== p.indexOf('BOMB')));
                    playSound('powerup');
                    setScreenShake(true);
                    setTimeout(() => setScreenShake(false), 500);
                    setStats(s => ({ ...s, powerUpsUsed: s.powerUpsUsed + 1 }));
                    return;
                }

                if (selectedPowerUp === 'SHIELD') {
                    if (board[row][col].player === 'black') {
                        setShieldedDiscs(sd => [...sd, { row, col, turns: 3 }]);
                        setSelectedPowerUp(null);
                        setPowerUps(p => p.filter((_, i) => i !== p.indexOf('SHIELD')));
                        playSound('powerup');
                        setStats(s => ({ ...s, powerUpsUsed: s.powerUpsUsed + 1 }));
                    }
                    return;
                }

                makeMove(row, col);
            };

            // AI Move
            useEffect(() => {
                if (currentPlayer === 'white' && gameState === 'playing' && !isAIThinking) {
                    setIsAIThinking(true);
                    
                    const thinkTime = difficulty === 'hard' ? 1500 : difficulty === 'medium' ? 800 : 400;
                    
                    setTimeout(() => {
                        const moves = getValidMoves(board, 'white');
                        if (moves.length === 0) {
                            switchTurn();
                            setIsAIThinking(false);
                            return;
                        }

                        let selectedMove;
                        
                        if (difficulty === 'easy') {
                            // Random move
                            selectedMove = moves[Math.floor(Math.random() * moves.length)];
                        } else if (difficulty === 'medium') {
                            // Greedy - most flips + corner priority
                            selectedMove = moves.reduce((best, move) => {
                                let score = move.flips.length;
                                // Corner bonus
                                if ((move.row === 0 || move.row === 7) && (move.col === 0 || move.col === 7)) {
                                    score += 10;
                                }
                                // Edge bonus
                                if (move.row === 0 || move.row === 7 || move.col === 0 || move.col === 7) {
                                    score += 2;
                                }
                                return score > (best.score || 0) ? { ...move, score } : best;
                            }, moves[0]);
                        } else {
                            // Hard - Minimax with alpha-beta pruning
                            selectedMove = minimaxMove(board, 4, 'white');
                        }

                        makeMove(selectedMove.row, selectedMove.col, true);
                        setIsAIThinking(false);
                    }, thinkTime);
                }
            }, [currentPlayer, gameState, board, difficulty, isAIThinking]);

            // Minimax algorithm
            function minimaxMove(board, depth, player) {
                const moves = getValidMoves(board, player);
                if (moves.length === 0) return null;

                let bestMove = moves[0];
                let bestScore = -Infinity;

                for (const move of moves) {
                    const newBoard = applyMove(board, move, player);
                    const score = minimax(newBoard, depth - 1, -Infinity, Infinity, false, player);
                    
                    // Corner bonus
                    if ((move.row === 0 || move.row === 7) && (move.col === 0 || move.col === 7)) {
                        score + 50;
                    }

                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = move;
                    }
                }

                return bestMove;
            }

            function minimax(board, depth, alpha, beta, isMaximizing, aiPlayer) {
                if (depth === 0) {
                    return evaluateBoard(board, aiPlayer);
                }

                const player = isMaximizing ? aiPlayer : (aiPlayer === 'white' ? 'black' : 'white');
                const moves = getValidMoves(board, player);

                if (moves.length === 0) {
                    return evaluateBoard(board, aiPlayer);
                }

                if (isMaximizing) {
                    let maxScore = -Infinity;
                    for (const move of moves) {
                        const newBoard = applyMove(board, move, player);
                        const score = minimax(newBoard, depth - 1, alpha, beta, false, aiPlayer);
                        maxScore = Math.max(maxScore, score);
                        alpha = Math.max(alpha, score);
                        if (beta <= alpha) break;
                    }
                    return maxScore;
                } else {
                    let minScore = Infinity;
                    for (const move of moves) {
                        const newBoard = applyMove(board, move, player);
                        const score = minimax(newBoard, depth - 1, alpha, beta, true, aiPlayer);
                        minScore = Math.min(minScore, score);
                        beta = Math.min(beta, score);
                        if (beta <= alpha) break;
                    }
                    return minScore;
                }
            }

            function applyMove(board, move, player) {
                const newBoard = board.map(r => r.map(c => ({ ...c })));
                newBoard[move.row][move.col] = { player, type: DISC_TYPES.NORMAL };
                move.flips.forEach(flip => {
                    newBoard[flip.row][flip.col].player = player;
                });
                return newBoard;
            }

            function evaluateBoard(board, aiPlayer) {
                let score = 0;
                const opponent = aiPlayer === 'white' ? 'black' : 'white';

                // Positional weights
                const weights = [
                    [100, -20, 10, 5, 5, 10, -20, 100],
                    [-20, -50, -2, -2, -2, -2, -50, -20],
                    [10, -2, 1, 1, 1, 1, -2, 10],
                    [5, -2, 1, 0, 0, 1, -2, 5],
                    [5, -2, 1, 0, 0, 1, -2, 5],
                    [10, -2, 1, 1, 1, 1, -2, 10],
                    [-20, -50, -2, -2, -2, -2, -50, -20],
                    [100, -20, 10, 5, 5, 10, -20, 100]
                ];

                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        if (board[r][c].player === aiPlayer) {
                            score += weights[r][c];
                            if (board[r][c].type === DISC_TYPES.GOLD) score += 5;
                        } else if (board[r][c].player === opponent) {
                            score -= weights[r][c];
                        }
                    }
                }

                return score;
            }

            // End game
            function endGame() {
                setGameState('ended');
                const winner = scores.black > scores.white ? 'player' : scores.white > scores.black ? 'ai' : 'draw';
                setResult({
                    winner,
                    scores: { ...scores },
                    stats: { ...stats }
                });
                playSound(winner === 'player' ? 'victory' : 'defeat');
            }

            // Check for game end
            useEffect(() => {
                if (gameState !== 'playing') return;
                
                const blackMoves = getValidMoves(board, 'black');
                const whiteMoves = getValidMoves(board, 'white');
                
                if (blackMoves.length === 0 && whiteMoves.length === 0) {
                    endGame();
                }
            }, [board, gameState]);

            // Start game
            function startGame() {
                setBoard(initializeBoard());
                setCurrentPlayer('black');
                setGameState('playing');
                setScores({ black: 2, white: 2 });
                setPowerUps(gameMode === 'strategy' ? ['BOMB', 'SHIELD', 'DOUBLE'] : []);
                setBoardPowerUps({});
                setBlackHoles([]);
                setFrozenCells({});
                setShieldedDiscs([]);
                setTurnCount(0);
                setNextEventIn(Math.floor(Math.random() * 4) + 5);
                setResult(null);
                setStats({ combos: 0, powerUpsUsed: 0, eventsLived: 0 });
                setGameHistory([]);
                setDoubleTurnActive(false);
                setGhostModeActive(false);
                setSniperModeActive(false);
                setSelectedPowerUp(null);
            }

            // Get valid moves for display
            const validMoves = currentPlayer === 'black' ? getValidMoves(board, 'black', ghostModeActive) : [];

            // Render
            return (
                <div className={`min-h-screen p-4 ${screenShake ? 'screen-shake' : ''}`}>
                    {/* Header */}
                    <header className="text-center mb-6">
                        <h1 className="font-orbitron text-4xl md:text-5xl font-black text-cyan-400 neon-text tracking-wider">
                            OTHELLO TWIST
                        </h1>
                        <p className="text-gray-400 mt-2 text-sm">‡πÄ‡∏Å‡∏°‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÉ‡∏Ñ‡∏£</p>
                    </header>

                    {gameState === 'menu' ? (
                        /* Menu Screen */
                        <div className="max-w-md mx-auto text-center">
                            <div className="bg-black/50 backdrop-blur-md rounded-2xl p-8 border border-cyan-500/30">
                                <h2 className="font-orbitron text-2xl text-white mb-6">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÇ‡∏´‡∏°‡∏î</h2>
                                
                                <div className="grid grid-cols-2 gap-3 mb-6">
                                    {['classic', 'chaos', 'strategy', 'speedrun'].map(mode => (
                                        <button
                                            key={mode}
                                            onClick={() => setGameMode(mode)}
                                            className={`btn-mode ${gameMode === mode ? 'active' : ''}`}
                                        >
                                            {mode === 'classic' && 'üéØ Classic'}
                                            {mode === 'chaos' && 'üå™Ô∏è Chaos'}
                                            {mode === 'strategy' && 'üß† Strategy'}
                                            {mode === 'speedrun' && '‚ö° Speedrun'}
                                        </button>
                                    ))}
                                </div>

                                <h2 className="font-orbitron text-2xl text-white mb-4">‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏Å</h2>
                                
                                <div className="flex justify-center gap-3 mb-8">
                                    {['easy', 'medium', 'hard'].map(diff => (
                                        <button
                                            key={diff}
                                            onClick={() => setDifficulty(diff)}
                                            className={`btn-mode ${difficulty === diff ? 'active' : ''}`}
                                        >
                                            {diff === 'easy' && 'üòä ‡∏á‡πà‡∏≤‡∏¢'}
                                            {diff === 'medium' && 'üòê ‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á'}
                                            {diff === 'hard' && 'üòà ‡∏¢‡∏≤‡∏Å'}
                                        </button>
                                    ))}
                                </div>

                                <button onClick={startGame} className="btn-neon w-full">
                                    üéÆ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°
                                </button>

                                <div className="mt-6 text-left text-gray-400 text-sm">
                                    <p className="mb-2"><strong className="text-cyan-400">Classic:</strong> Othello ‡∏î‡∏±‡πâ‡∏á‡πÄ‡∏î‡∏¥‡∏°</p>
                                    <p className="mb-2"><strong className="text-cyan-400">Chaos:</strong> ‡∏°‡∏µ Power-Up + Random Event</p>
                                    <p className="mb-2"><strong className="text-cyan-400">Strategy:</strong> ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Power-Up ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô 3 ‡∏ä‡∏¥‡πâ‡∏ô</p>
                                    <p><strong className="text-cyan-400">Speedrun:</strong> Power-Up ‡πÄ‡∏¢‡∏≠‡∏∞‡∏Ç‡∏∂‡πâ‡∏ô!</p>
                                </div>
                            </div>
                        </div>
                    ) : (
                        /* Game Screen */
                        <div className="max-w-4xl mx-auto">
                            {/* Score and Status */}
                            <div className="flex justify-between items-center mb-4 px-2">
                                <div className="score-card">
                                    <div className="flex items-center gap-3">
                                        <div className="w-8 h-8 rounded-full bg-gradient-to-br from-gray-700 to-black shadow-lg"></div>
                                        <div>
                                            <div className="text-xs text-gray-400">‡∏Ñ‡∏∏‡∏ì</div>
                                            <div className="score-value text-cyan-400">{scores.black}</div>
                                        </div>
                                    </div>
                                </div>

                                <div className={`turn-indicator ${currentPlayer === 'black' ? 'player-turn' : 'ai-turn'}`}>
                                    {isAIThinking ? (
                                        <div className="flex items-center gap-2">
                                            <span className="text-white">AI ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏Ñ‡∏¥‡∏î</span>
                                            <div className="ai-thinking">
                                                <span></span>
                                                <span></span>
                                                <span></span>
                                            </div>
                                        </div>
                                    ) : (
                                        <span className="text-white font-medium">
                                            {currentPlayer === 'black' ? 'üéÆ ‡∏ï‡∏≤‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì' : 'ü§ñ ‡∏ï‡∏≤ AI'}
                                        </span>
                                    )}
                                </div>

                                <div className="score-card">
                                    <div className="flex items-center gap-3">
                                        <div>
                                            <div className="text-xs text-gray-400">AI</div>
                                            <div className="score-value text-pink-400">{scores.white}</div>
                                        </div>
                                        <div className="w-8 h-8 rounded-full bg-gradient-to-br from-white to-gray-300 shadow-lg"></div>
                                    </div>
                                </div>
                            </div>

                            {/* Game info */}
                            {gameMode === 'chaos' && (
                                <div className="text-center mb-3">
                                    <span className="text-yellow-400 text-sm">
                                        ‚ö†Ô∏è Event ‡∏ñ‡∏±‡∏î‡πÑ‡∏õ‡πÉ‡∏ô {nextEventIn - turnCount} ‡∏ï‡∏≤
                                    </span>
                                </div>
                            )}

                            {/* Active modes */}
                            <div className="flex justify-center gap-2 mb-3">
                                {doubleTurnActive && (
                                    <span className="bg-yellow-500/20 text-yellow-400 px-3 py-1 rounded-full text-sm">
                                        ‚ö° Double Turn Active!
                                    </span>
                                )}
                                {ghostModeActive && (
                                    <span className="bg-purple-500/20 text-purple-400 px-3 py-1 rounded-full text-sm">
                                        üëª Ghost Mode Active!
                                    </span>
                                )}
                                {sniperModeActive && (
                                    <span className="bg-red-500/20 text-red-400 px-3 py-1 rounded-full text-sm">
                                        üéØ Sniper Mode - ‡∏Ñ‡∏•‡∏¥‡∏Å‡∏´‡∏°‡∏≤‡∏Å‡∏®‡∏±‡∏ï‡∏£‡∏π!
                                    </span>
                                )}
                                {selectedPowerUp && (
                                    <span className="bg-cyan-500/20 text-cyan-400 px-3 py-1 rounded-full text-sm">
                                        {POWER_UPS[selectedPowerUp].icon} {POWER_UPS[selectedPowerUp].name} - ‡∏Ñ‡∏•‡∏¥‡∏Å‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á
                                    </span>
                                )}
                            </div>

                            {/* Board */}
                            <div className="flex justify-center mb-4">
                                <div ref={boardRef} className="game-board w-full max-w-[400px]">
                                    {board.map((row, rowIdx) => (
                                        row.map((cell, colIdx) => {
                                            const isValidMove = validMoves.some(m => m.row === rowIdx && m.col === colIdx);
                                            const isBlackHole = blackHoles.some(bh => bh.row === rowIdx && bh.col === colIdx);
                                            const isFrozen = frozenCells[`${rowIdx}-${colIdx}`];
                                            const powerUp = boardPowerUps[`${rowIdx}-${colIdx}`];
                                            const isShielded = shieldedDiscs.some(s => s.row === rowIdx && s.col === colIdx);

                                            return (
                                                <div
                                                    key={`${rowIdx}-${colIdx}`}
                                                    className={`cell ${cell.player ? 'has-disc' : ''} ${isValidMove ? 'valid-move' : ''} ${isBlackHole ? 'black-hole' : ''} ${isFrozen ? 'frozen' : ''}`}
                                                    onClick={() => handleCellClick(rowIdx, colIdx)}
                                                >
                                                    {cell.player && (
                                                        <div className={`disc disc-${cell.player} ${cell.type !== DISC_TYPES.NORMAL ? `disc-${cell.type}` : ''} ${isShielded ? 'disc-shielded' : ''}`}>
                                                        </div>
                                                    )}
                                                    {powerUp && !cell.player && (
                                                        <span className="power-up-cell">{POWER_UPS[powerUp].icon}</span>
                                                    )}
                                                </div>
                                            );
                                        })
                                    ))}
                                </div>
                            </div>

                            {/* Power-ups inventory */}
                            {gameMode !== 'classic' && (
                                <div className="flex justify-center gap-3 mb-4">
                                    <span className="text-gray-400 self-center mr-2">Power-Ups:</span>
                                    {[0, 1, 2].map(i => (
                                        <div
                                            key={i}
                                            className={`power-up-slot ${powerUps[i] && selectedPowerUp === powerUps[i] ? 'selected' : ''}`}
                                            onClick={() => powerUps[i] && usePowerUp(powerUps[i])}
                                            title={powerUps[i] ? POWER_UPS[powerUps[i]].desc : '‡∏ß‡πà‡∏≤‡∏á'}
                                        >
                                            {powerUps[i] ? POWER_UPS[powerUps[i]].icon : ''}
                                        </div>
                                    ))}
                                </div>
                            )}

                            {/* Controls */}
                            <div className="flex justify-center gap-4">
                                <button onClick={startGame} className="btn-neon text-sm">
                                    üîÑ ‡πÄ‡∏Å‡∏°‡πÉ‡∏´‡∏°‡πà
                                </button>
                                <button onClick={() => setGameState('menu')} className="btn-neon text-sm" style={{ borderColor: '#ff00ff', color: '#ff00ff' }}>
                                    üè† ‡πÄ‡∏°‡∏ô‡∏π‡∏´‡∏•‡∏±‡∏Å
                                </button>
                            </div>
                        </div>
                    )}

                    {/* Event Popup */}
                    {currentEvent && (
                        <>
                            <div className="overlay"></div>
                            <div className="event-popup">
                                <div className="event-icon">{EVENTS[currentEvent].icon}</div>
                                <h2 className="font-orbitron text-3xl text-pink-400 neon-text-magenta mb-4">
                                    {EVENTS[currentEvent].name}
                                </h2>
                                <p className="text-white text-xl">{EVENTS[currentEvent].desc}</p>
                            </div>
                        </>
                    )}

                    {/* Combo Popup */}
                    {combo && (
                        <div 
                            className="combo-popup"
                            onAnimationEnd={() => setCombo(null)}
                        >
                            üî• {combo.name} {combo.desc}
                        </div>
                    )}

                    {/* Result Screen */}
                    {result && (
                        <>
                            <div className="overlay"></div>
                            <div className={`result-screen ${result.winner === 'player' ? 'victory' : 'defeat'}`}>
                                <div className="text-6xl mb-4">
                                    {result.winner === 'player' ? 'üéâ' : result.winner === 'ai' ? 'üò¢' : 'ü§ù'}
                                </div>
                                <h2 className={`font-orbitron text-4xl mb-6 ${result.winner === 'player' ? 'text-cyan-400 neon-text' : 'text-pink-400 neon-text-magenta'}`}>
                                    {result.winner === 'player' ? 'VICTORY!' : result.winner === 'ai' ? 'DEFEAT' : 'DRAW'}
                                </h2>
                                
                                <div className="text-white text-2xl mb-6">
                                    {result.scores.black} - {result.scores.white}
                                </div>

                                <div className="text-left bg-black/30 rounded-lg p-4 mb-6">
                                    <h3 className="text-cyan-400 font-bold mb-2">üìä ‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥</h3>
                                    <p className="text-gray-300">Combo ‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ: {result.stats.combos}</p>
                                    <p className="text-gray-300">Power-Up ‡πÉ‡∏ä‡πâ: {result.stats.powerUpsUsed}</p>
                                    <p className="text-gray-300">Event ‡∏£‡∏≠‡∏î: {result.stats.eventsLived}</p>
                                </div>

                                <div className="flex gap-4 justify-center">
                                    <button onClick={startGame} className="btn-neon">
                                        üîÑ ‡πÄ‡∏•‡πà‡∏ô‡∏≠‡∏µ‡∏Å
                                    </button>
                                    <button 
                                        onClick={() => { setResult(null); setGameState('menu'); }} 
                                        className="btn-neon"
                                        style={{ borderColor: '#ff00ff', color: '#ff00ff' }}
                                    >
                                        üè† ‡πÄ‡∏°‡∏ô‡∏π‡∏´‡∏•‡∏±‡∏Å
                                    </button>
                                </div>
                            </div>
                        </>
                    )}
                </div>
            );
        }

        // Render
        ReactDOM.createRoot(document.getElementById('app')).render(<OthelloTwist />);
    </script>
</body>
</html>
